  /*%NOCOMMENT -------------  rexx procedure  -------------------- */
  ftpbver = "2.034"
  /* Name:      FTPB                                               *
  *                                                               *
  * Function:  Generate a Batch TCP/IP FTP Job                    *
  *                                                               *
  * Syntax:    %ftpb send_dsname options                          *
  *                                                               *
  *            where options are:                                 *
  *             ANONYMOUS                                         *
  *             BINARY                                            *
  *             HOST host-name                                    *
  *             PORT port-number                                  *
  *             MVS or NOMVS                                      *
  *                                                               *
  * Author:    Lionel B. Dyck                                     *
  *                                                               *
  * Contributions and Acknowledgements.....                       *
  *                                                               *
  *   Rob Parenti - improved directory support when target is     *
  *                 MVS HFS or non-MVS                            *
  *                                                               *
  *   Eric Wolf:                                                  *
  *   Support added:                                              *
  *   VSAM                <== replaced by adrdssu code            *
  *   Firewall                                                    *
  *   Save Password (changed to an option via switch)             *
  *   root directory support                                      *
  *   e-mail: eric.wolff@westernsouthernlife.com                  *
  *                                                               *
  *   Dennis Roach for the RACF ADDSD/PERMIT for Netrc            *
  *                                                               *
  *   Ole Knudsen                                                 *
  *   GDG level extract routine.                                  *
  *                                                               *
  *   Linda Thomas and Skip Robinson - lots of great suggestions  *
  *                                                               *
  *   Skip Robinson - provided the code to test the return        *
  *                   code of the remote submission job.          *
  *                                                               *
  *   Werner Kuehnel - more great suggestions and an updated      *
  *                    find_vsam_space routine                    *
  *                                                               *
  *   John Kalinich  - pds directory read routine in rexx         *
  *                  - ACF2 ACFNRULE for NETRC protection         *
  *                                                               *
  *   Ray Mullins    - add BYPASSACS support, minor fixes         *
  *                                                               *
  * Installation customization:                                   *
  *   1. Update the FTPBCUST REXX exec for your installation      *
  *      defaults.                                                *
  *   2. Let me know if I missed tagging a section                *
  *   3. find 'pdo 9712' and uncomment if you have problems       *
  *      with ftp'ing unloaded datasets that originally have      *
  *      a variable recfm and a blksize > 32756.                  *
  *   4. An ISPF table is used for jobcard information in         *
  *      the default table library (thus isptabl must be in       *
  *      isptlib).                                                *
  *                                                               *
  * Requirements:                                                 *
  *                                                               *
  * History:                                                      *
  *            11/09/2024  - 2.034  - Correct Sync test for remote*
  *                                   dataset                     *
  *            01/16/2024  - 2.033  - Fix overzealous refactor    *
  *            01/03/2024  - 2.032  - Finish nomenclanture update *
  *                                   (from->local, to->remote,   *
  *                                   sdsname->ldsname,           *
  *                                   tdsname->rdsname)           *
  *                                 - Correct data set processed  *
  *                                   in Do_Get                   *
  *                                 - Cancel request if PF3 used  *
  *                                   leaving panels FTPBUNLD and *
  *                                   FTPBGSU                     *
  *                                 - Set defaults before calling *
  *                                   FTPBCUST                    *
  *                                 - Preinitialize some ISPF and *
  *                                   LISTDSI returned variables  *
  *                                 - Remove some duplicate       *
  *                                   statements                  *
  *            03/17/2023  - 2.031  - Add support for specifying  *
  *                                   BYPASSACS when using DSS    *
  *                                 - Translate &direct on        *
  *                                   FTPBSITE as miniscule "p"   *
  *                                   is put in LOAD step as-is   *
  *                                 - Fix issue with multiple     *
  *                                   ENDIF/multiple delete steps *
  *            02/16/2023  - 2.030  - Fix Sync Get/Put changes    *
  *            02/10/2023  - 2.029  - Correct dates on Sync       *
  *            01/23/2023  - 2.028  - Allow No for NONE on DSS    *
  *                                   restore                     *
  *            01/13/2023  - 2.027  - Correct Sync double Ignore  *
  *                                 - Correct Sync xfer counter   *
  *                                 - Update Sync for NoStats and *
  *                                   Not There                   *
  *                                 - Update Sync dates with .    *
  *                                 - Used REXXFORM 3 2 to reflow *
  *            01/01/2023  - 2.026  - Restore DELSTEP for Load DD *
  *                                   for iebcopy/adrdssu         *
  *                                 - Comment DELLOAD DD in Local *
  *                                   JCL for DELSTEP for Restart *
  *            01/01/2023  - 2.025  - Add delete step for unload  *
  *                                   for iebcopy/adrdssu         *
  *                                 - Clean up DELSTEP            *
  *            12/30/2022  - 2.024  - Fix if invalid host and     *
  *                                   NETRC in use                *
  *            11/04/2022  - 2.023  - Submit option R added       *
  *                                 - Thx to Dana Mitchell for    *
  *                                   TSS commands to secure the  *
  *                                   NETRC dataset               *
  *            08/19/2022  - 2.022  - Allow user to cancel if to  *
  *                                   dataset does not exist.     *
  *            04/11/2022  - 2.021  - Used EPSV4 with Passive     *
  *                                 - Allow Sync display delta    *
  *            03/21/2022  - 2.020  - Allow multiple Compares on  *
  *                                   Sync                        *
  *                                 - Free FTP JCL DD after Sync  *
  *                                   if noaction                 *
  *            03/17/2022  - 2.019  - Option to unload a PDS FTP  *
  *            03/03/2022  - 2.018  - Correct sync compare dsn    *
  *            03/01/2022  - 2.017  - Fix LOAD of PDS missing     *
  *                                   dir blocks                  *
  *            02/18/2022  - 2.016  - Correct unload space alloc  *
  *                                 - Correct IF test             *
  *                                 - Correct BLKSIZE if not sdb  *
  *                                 - Add DSORG=PO on Reload DD   *
  *                                 - Correct RENAMEU if masked   *
  *            02/04/2022  - 2.015  - Correct unload space        *
  *                                 - // IF/ENDIF in Unload (mrm) *
  *                                 - Better align unload jcl     *
  *            01/21/2022  - 2.014  - Check FTP error on GET      *
  *            01/18/2022  - 2.013  - On a Sync check the Compare *
  *                                   using Edit rc and setmsg    *
  *            12/07/2021  - 2.012  - Add Sync option R to remove *
  *                                   (aka delete) the local PDS  *
  *                                   member.                     *
  *            10/23/2021  - 2.011  - Check if remote PDS member  *
  *                                   compare failed due to a     *
  *                                   possible ENQ                *
  *            06/23/2021  - 2.010  - Fix get dsname ending .     *
  *            06/14/2021  - 2.009  - Add check for remote errors *
  *            05/12/2021  - 2.008  - Add other for Sync/Get      *
  *                                 - Add Passive on FTPB panel   *
  *            04/23/2021  - 2.007  - Remove debug say statement  *
  *            04/21/2021  - 2.006  - Add mode b/type e for GET   *
  *            04/16/2021  - 2.005  - Add port to ftpjobcd table  *
  *                                   key                         *
  *            04/15/2021  - 2.004  - Use MVSGET for FTPB GET     *
  *            04/15/2021  - 2.003  - On Get prompt if DSORG=U    *
  *                                   for PDS or PDSE             *
  *            04/06/2021  - 2.002  - Improve ADRDSSU processing  *
  *                                   COMPRESS -> HWCOMPRESS and  *
  *                                   add OPTIMIZE(4)             *
  *            04/06/2021  - 2.001  - Correct GET newhlq          *
  *            04/02/2021  - 2.000  - Move SYNC option to         *
  *                                   Direction                   *
  *                                 - Term change Source->From    *
  *                                   Target->To                  *
  *                                 - For Remote Job Card read    *
  *                                   userid from NETRC if none   *
  *            03/29/2021  - 1.258  - Correct VSAM on Get         *
  *            03/27/2021  - 1.257  - Add GET option              *
  *            03/23/2021  - 1.256  - Prevent dups from remote    *
  *            03/22/2021  - 1.255  - Support Empty from/to PDS   *
  *                                   for Sync.                   *
  *            03/15/2021  - 1.254  - Allow Edit Submit if NETRC  *
  *            03/14/2021  - 1.253  - Add NETRC DD comments       *
  *            03/12/2021  - 1.252  - Correct 1.251 bug (dup sync)*
  *            03/11/2021  - 1.251  - Correct 1.250 bug           *
  *            03/11/2021  - 1.250  - Fix sync for mems nostats   *
  *            03/09/2021  - 1.249  - Clean up sync count msg     *
  *            02/11/2021  - 1.248  - Correct unload recfm=u new  *
  *            02/08/2021  - 1.247  - Remove OS Level Check as    *
  *                                   obsolete                    *
  *                                 - FIX 1st pass job card setup *
  *            02/03/2021  - 1.246  - Reverse cd/lcd for sync     *
  *            01/27/2021  - 1.245  - Correct Sort for Sync for   *
  *                                   remote only members         *
  *            01/25/2021  - 1.244  - Improved NETRC tutorial and *
  *                                   FTPBCUST                    *
  *            01/25/2021  - 1.243  - Prompt if specified NETRC   *
  *                                   does not exist.             *
  *                                 - Correctly handle empty      *
  *                                   jobcard/host table          *
  *            01/25/2021  - 1.242  - Add ACF2 protection option  *
  *            01/24/2021  - 1.241  - Fix sync member selection   *
  *            01/24/2021  - 1.240  - If dataset pattern and Sync *
  *                                   error message               *
  *            01/23/2021  - 1.239  - Pattern matching for Sync   *
  *                                 - Only delete ignore entry    *
  *                                   after a Clear               *
  *            01/22/2021  - 1.238  - Numerous fixes during Beta  *
  *            01/21/2021  - 1.237  - Add NETRC management support*
  *                                 - Clean up alloc for PDSE     *
  *                                 - Add Remote SYNC option      *
  *            01/14/2021  - 1.236  - Remember port from panel    *
  *            01/05/2021  - 1.235  - Fix BLOCK allocation sizing *
  *            06/29/2020  - 1.234  - Don't proceed on host table *
  *                                   until > 0 entries selected  *
  *            09/06/2019  - 1.233  - Move lcd before cd          *
  *            08/22/2019  - 1.232  - Correction from Peter       *
  *                                   Glanzmann to support        *
  *                                   NETRC as a PDS member.      *
  *            08/20/2019  - 1.231  - Correct if no NETRC         *
  *            07/01/2019  - 1.230  - Add user NETRC support      *
  *                                 - reflow using REXXFORM       *
  *            03/06/2019  - 1.229  - Remove extra blank from parm*
  *            01/30/2019  - 1.228  - Add Sort option for hosts   *
  *            02/01/2018  - 1.227  - Fix for port/tls            *
  *            05/11/2017  - 1.226  - Add Port option             *
  *                                 - Move TLS and add to table   *
  *            07/29/2016  - 1.225  - Add TLS option              *
  *            05/04/2016  - 1.224  - Change from William Smith   *
  *            Clean up for z/OS 2.2, William J. Smith,           *
  *                                   San Francisco, CA           *
  *                                   sfowjs@sbcglobal.net        *
  *                                   (415) 531-7667              *
  *                                                               *
  *            07/10/2009  - 1.223  - Change from Rick Turnbull   *
  *                                   to enhance support for HFS  *
  *                                   files by allowing lower     *
  *                                   case file names             *
  *            02/17/2009  - 1.222  - Change in Package only      *
  *            02/11/2009  - 1.221  - Reset big_load variable     *
  *            01/27/2009  - 1.220  - Update to enable support    *
  *                                   for PDSE from               *
  *                                   eric.hamtiaux@fortis.com    *
  *            07/28/2008  - 1.219  - 1 fix                       *
  *            07/08/2008  - 1.218  - 2 fix from Eric Hamtiaux    *
  *                                   if sending pds with 1 mem   *
  *                                   and correct cleanup         *
  *            06/14/2007  - 1.217  - 2 fixes from Bernd Krawczyk *
  *                                 - correct if multiple host se *
  *                                 - correct long filename       *
  *                                 - fix from Larry Belikoff     *
  *                                   for new BLK allocated files *
  *            05/02/2005  - 1.216  - Fix space for adrdssu with  *
  *                                   recfm=vbs                   *
  *            04/12/2004  - 1.215  - Clean up NETRC allocation   *
  *            04/09/2004  - 1.214  - Add userid to netrc hlq     *
  *                                   if prefix is /= userid      *
  *            03/23/2004  - 1.213  - New NETSEC support          *
  *            01/26/2004  - 1.212  - Fix Find Routine (minor)    *
  *            07/30/2003  - 1.211  - Correct DSS dump space alloc*
  *                                   thx to Don Ristagno         *
  *            06/30/2003  - 1.210  - Correct HFS space unload    *
  *            06/27/2003  - 1.209  - Dynamically get the rexx    *
  *                                   library for the sysexec     *
  *                                   for batch.                  *
  *            06/06/2003  - 1.208  - For PDSE Unload add DSNTYPE *
  *                                   reload jcl.                 *
  *                                 - Correct BLK in space        *
  *                                 - Correct reload dsn on put   *
  *            05/07/2003  - 1.207  - Use DSINFO to support HFS   *
  *                                   data sets.                  *
  *                                 - correct delload dsns        *
  *                                 - update df/dss dsn select    *
  *                                   for HFS files               *
  *            04/21/2003  - 1.206  - allow tape input d/s        *
  *                                 - support OMVS files          *
  *                                   thx to Eric Hamtiaux        *
  *                                 - add popup prompt for        *
  *                                   anonymous password          *
  *                                 - for df/dss for space to tr  *
  *                                 - add remote hlq option       *
  *                                 - correct pds alloc type site *
  *                                 - support target dsn with /   *
  *                                   or \ for windows or *nix    *
  *                                 - prompt for output info (ps) *
  *                                 - support hfs files           *
  *                                 - support steplib cust        *
  *                                 - support 1 post ftp cmd      *
  *                                 - add passlib to recursive    *
  *                                   call                        *
  *            10/18/2002  - 1.204  - add data/mgmt/storclass     *
  *            09/16/2002  - 1.203  - update for create/replace   *
  *                                   back to yes/no              *
  *            09/03/2002  - 1.202  - Fix problem lcd s/b cd      *
  *            08/29/2002  - 1.201  - Change 'new' pds to         *
  *                                   Create or Replace           *
  *                                 - Add new delete option       *
  *                                   to generate delete on create*
  *            08/17/2002  - 1.200  - add 4th job statement       *
  *                                   per Robert Iappini          *
  *            05/08/2002  - 1.199  - add dcb for output alloc    *
  *            02/18/2002  - 1.198  - minor fix for find routine  *
  *            09/04/2001  - 1.197  - test for os/390 v2r10       *
  *                                   which supports ftp of load  *
  *                                 - fix reload dsn hlq issue    *
  *            06/21/2001  - 1.196  - cleanup netrc files         *
  *                                 - more fix for noprefix       *
  *            06/07/2001  - 1.195  - various updates for noprefix*
  *            02/21/2001  - 1.194  - add nodsnopt if no dsns     *
  *                                   selected                    *
  *            02/20/2001  - 1.193  - fix noprefix jcl build      *
  *                                 - elimate prompt if non-mvs   *
  *                                 - fix netrc usage to WORK     *
  *                                 - add no member select option *
  *                                   nomemopt variable           *
  *                                 - fix split screen usage      *
  *            02/07/2001  - 1.192  - fixed member patter *xx*    *
  *            02/02/2001  - 1.191  - fixed several issues        *
  *                                 - loop with invalid member    *
  *                                   pattern                     *
  *                                 - unselect never selected mem *
  *            05/31/2000  - 1.190  - fixed anonymous usage       *
  *            05/18/2000  - 1.189  - add TOL(ENQF) option        *
  *                                 - add ALLDATA(*) option       *
  *                                 - corrections for CATALOG     *
  *                                   and for VSAM .D and .I      *
  *                                   thx to Larry Belikoff       *
  *            03/11/2000  - 1.188  - add systcpd and systcpds    *
  *                                   from Bert Lindeman          *
  *            02/11/2000  - 1.187  - move site vol before mkdir  *
  *            01/12/2000  - 1.186  - remove (Exit for online FTP *
  *            11/09/99    - 1.185  - fix netrc and allow netrc   *
  *                                   in foreground               *
  *                                 - change sysout(b) to (a)     *
  *            11/02/99    - 1.184  - fix netrc                   *
  *            10/22/99    - 1.183  - allow Create/Replace to     *
  *                                   word for non-unload         *
  *            10/20/99    - 1.182  - sort target host table      *
  *            10/15/99    - 1.181  - fix rfind                   *
  *            10/14/99    - 1.180  - add find to host table list *
  *            09/24/99    - 1.171  - move sysftpds to ftpbcust   *
  *            09/21/99    - 1.170  - add options for direct use  *
  *            06/27/99    - 1.166  - fix members in s m=()       *
  *            06/23/99    - 1.165  - fix location of SYSFTPD DD  *
  *            06/03/99    - 1.164  - fix popup for submit for dss*
  *            04/21/99    - 1.163  - add locsite lrecl for getput*
  *            04/20/99    - 1.162  - fix vsam space problem      *
  *            04/20/99    - 1.161  - Minor cleanup for jobcard   *
  *            04/19/99    - 1.160  - Move customized options to  *
  *                                   external exec: ftpbcust     *
  *                                   - changed variable names    *
  *            04/09/99    - 1.151  - Make nmc and nsc upper case *
  *            04/09/99    - 1.150  - add variable for unit (3390)*
  *                                 - fix sp to TR                *
  *                                 - add target host description *
  *                                 - misc. corrections           *
  *                                 - add REFRESH option          *
  *            03/23/99    - 1.141  - add SYSFTPD DD (optional)   *
  *            03/23/99    - 1.140  - major change in dfdss       *
  *                                   dataset selection process   *
  *                                 - add recfm(fb) to intrdr     *
  *                                 - add NETRC DD for batch      *
  *                                   as an option                *
  *            03/19/99    - 1.132  - fixes from Werner           *
  *                          - for pattern add ** for *           *
  *                          - fix space variable in some cases   *
  *                          - remove quotes from dss dsname      *
  *                          - test for null 3rd job statement    *
  *            03/18/99    - 1.131  - unsel for host select       *
  *            10/17/98    - 1.130  - cleanup submit datasets     *
  *            .... history cleaned up                            *
  *            06/03/97    - 1.000  - set to Version 1.000        *
  *            11/21/96-12/02/96 - creation                       *
  * ------------------------------------------------------------- */

  parse arg options

  /* -------------------------------------- *
  * Test for uss file format with wildcard *
  * -------------------------------------- */
  if pos("/",options) > 0 then do
    if pos("*",options) > 0 then do
      say "Syntax error. An initial option of" options ,
        "is not allowed. Enter the dialog and enter it"  ,
        "in the Local dataset field."
      exit 16
    end
  end
  else do
    options = translate(options)
  end

  Address ISPEXEC
  zapplid = ""
  "Vget zapplid"
  "Control Errors Return"
  if zapplid <> "FTP" then do
    Address ISPEXEC
    "TBCreate ftpcmds names(zctverb zcttrunc zctact zctdesc)",
      "replace share nowrite"
    zctverb = "RFIND"
    zcttrunc = 0
    zctact = "&FTPRFIND"
    zctdesc = "RFIND for FTP Dialog"
    "TBAdd ftpcmds"
    "Select CMD(%"sysvar('sysicmd') options ") Newappl(FTP)" ,
      "Passlib"
    "TBEnd ftpcmds"
    Exit 0
  end

  parse value "" with null loadjcl_dsn_flag password passwvfy ,
    ddn big_load odyvol odysc odymc odddsn obpac shost mems ,
    loadjcl_dsn save_port ,
    sysblksize syslrecl sysrecfm sysused sysvolume,
    zerrmsg zerrsm zerrlm zuser zprefix

  /* Set defaults before customization */
  parse value 0 with 1 sdb 1 netrc 1 netrcpre 1 netsec 1 sysftpd 1 savepwd ,
    1 FirIDwH 1 systcpd 1 nomemopt 1 nodsnopt
  parse value null with steplib systcpds jc1 jc2 jc3 jc4
  vio  = "VIO"
  dasd = "3390"
  tape = "CART"
  sysftpds = "TCPIP.FTP.DATA"
  forcejbn = "Y"

  "Select Cmd(ftpbcust)"
  "Vget (sdb vio dasd netrc netsec sysftpd njenode savepwd" ,
    "FirIDwH forcejbn jc1 jc2 jc3 jc4 sysftpds systcpd" ,
    "systcpds nomemopt nodsnopt tape steplib" ,
    "syd netrcpre)"
  Address TSO

  /* -------------------------- *
  * If options is null then    *
  * set send dsname (ldsname)  *
  * -------------------------- */
  if length(options) > 0 then
  parse value options with ldsname more
  else ldsname = null

  /* ----------------------------------------------------- *
  * Test and process any options                          *
  *    MVS or NOMVS sets the mvs value to Yes or No       *
  *    ANONYMOUS sets the userid to anonymous             *
  *    BINARY sets the bin value to Yes                   *
  *    HOST sets the remote host to the host name         *
  *         supplied as the next word in the options      *
  * ----------------------------------------------------- */
  if length(more) > 0 then do
    more = translate(more)
    If wordpos("MVS",more)   > 0 then mvs = "Y"
    If wordpos("NOMVS",more) > 0 then mvs = "N"
    If wordpos("BINARY",more) > 0 then bin = "Y"
    If wordpos("ANONYMOUS",more) > 0 then userid = "anonymous"
    If wordpos("HOST",more) > 0 then do
      x = wordpos("HOST",more)
      thost = word(more,x+1)
    end
    If wordpos("PORT",more) > 0 then do
      x = wordpos("PORT",more)
      thport = word(more,x+1)
    end
  end

  /* -------------------------- *
  * Set default Environment    *
  * -------------------------- */
  Address ISPExec

  /* -------------------------- *
  * Add Version to ISPF Pool   *
  * -------------------------- */
  "Vput (ftpbver ldsname)"

  /* -------------------------- *
  * Get basic information      *
  * -------------------------- */
  "Vget (zuser zprefix)"

  /* ----------------------------- *
  * If password saved then get it *
  * ----------------------------- */
  if savepwd = 1 then
  "Vget (password passwvfy) Profile"

  alloc_netrc = 0

Start:
  /* -------------------------- *
  * Do Forever displaying      *
  * the FTPB Panel             *
  * -------------------------- */
  Do forever
    if alloc_netrc = 1 then do
      if usernrc = null
      then "Delete '"netrc_dsn"'"
      else "Free F(NETRC)"
      alloc_netrc = 0
    end
    parse value null with ftp. load. members do_pds_flag od ,
      mhst submit_flag loadjcl_dsn_flag dss tape_fl
    ftp.0  = 0
    load.0 = 0
    dc     = 0
    unl    = 'No'
    excluded.0 = 0
    selected.0 = 0
    big_load = null
    if loadjcl_dsn_flag = 1 then
    if submit_flag <> 1 then call clean_up_submit
    submit_flag      = null
    loadjcl_dsn_flag = null
    zcmd = null

    if shost <> null then do
      thost = shost
      shost = null
    end
    if thost = "*****" then thost = "?"

    ftprfind = "PASSTHRU"
    "Vput ftprfind"

    if save_port /= null then
    thport = save_port
    "Display Panel(ftpb)"
    if rc > 4 then do
      if savepwd = 1 then exit
      parse value "" with password passwvfy
      exit
    end

    save_port = thport
    if translate(ldsname) = "EGG" then do
      Address TSO "%ftpbcrdt"
      ldsname = null
    end
    else do
      zedsmsg = null
      if ftpgp = 'S' then do /* Sync */
        if pos('*',ldsname) > 0 then
        if pos('(',ldsname) = 0 then do
          zedsmsg = 'Invalid'
          zedlmsg = 'Sync is not allowed with a dataset mask.'
          'setmsg msg(isrz001)'
        end
        if zedsmsg = null then do
          if pos('(',ldsname) > 0
          then do
            p = pos('(',ldsname)
            parse value ldsname with test_ldsname'('sync_member')' .
            if left(ldsname,1) = "'"
            then test_ldsname = test_ldsname"'"
          end
          else do
            test_ldsname = ldsname
            sync_member = null
          end
          x = listdsi(test_ldsname 'DIR')
          if sysrecfm = 'U' then do
            zedsmsg = 'Invalid'
            zedlmsg = 'Sync is not allowed for Load Libraries.'
            'setmsg msg(isrz001)'
          end
        end
      end
      if zedsmsg = null then do
        if usernrc = null then do
          call do_it
        end
        else do
          if usernrc /= null
          then if sysdsn(usernrc) = 'OK'
          then call do_it
          else do
            x = ftpbnrc(usernrc)
          end
        end
      end
    end
  end

  /* ---------------------------------------------------------- *
  * Start the actual processing with the Do_It procedure.      *
  * ---------------------------------------------------------- */

Do_It:
  if pos("/",ldsname) = 0 then
  ldsname = translate(ldsname)
  "Vput (ldsname thost userid bin mvs other usernrc" ,
    "thport fir tls psv firewall syd post ftpgp) Profile"

  /* ------------------------ *
  * Test for Feedback option *
  * ------------------------ */
  if abbrev("FEEDBACK",zcmd,2) = 1 then do
    zcmd = null
    feedback = "lbdyck@gmail.com"
    Address TSO,
      "%genrfdbk FTPBatch" ftpbver feedback
    return
  end

  /* ---------------------------------------------- *
  | Fixup the user netrc data set name for JCL use |
  * ---------------------------------------------- */
  if usernrc /= null then do
    sysdsname = null
    x = listdsi(usernrc)
    if pos('(',usernrc) = 0
    then usernrcl = sysdsname
    else do
      parse value usernrc with .'('nrcm')'.
      usernrcl = sysdsname'('nrcm')'
    end
  end

  /* -------------------------- *
  * Clear some variables       *
  * -------------------------- */
  parse value null with to_mem to_dsn from_dsn ldsnamex rdsnamex ,
    gdg rename multiple sysalloc sysseconds direct sp

  /* --------------------------------------------------------- *
  * Setup HLQ and MLQ and RHLQ (remote)                       *
  * --------------------------------------------------------- */
  if length(zprefix) = 0
  then  hlq = zuser
  else if zuser <> zprefix
  then hlq = zprefix"."zuser
  else hlq = zuser
  mlq = "FTP"
  if netrcpre = 0
  then netrc_hlq = hlq
  else netrc_hlq = zuser
  rhlq = translate(userid)
  whlq = rhlq

  if pos(ftpgp,'PS') > 0 then do  /* Sync */
    /* -------------------------- *
    * Find sending member ?      *
    * or if multiple dsn xfer ?  *
    * -------------------------- */
    Select
      when left(ldsname,1) = "/" then nop
      when pos("(",ldsname) > 0 then do
        parse value ldsname with ldsnamex "(" members ")"
        Select
          When pos(left(members,1),"-+") > 0 then call get_gdg
          When datatype(members) = "NUM" then call get_gdg
          Otherwise nop
        end
        if gdg = null then
        if left(ldsnamex,1) = "'" then
        ldsnamex = ldsnamex"'"
      end
      /* ----------------------------------------------------- *
      * Look for wildcard.                                    *
      * - set multiple flag on                                *
      * - if .* then make .** as df/dss requires that for     *
      *   more than a single level                            *
      * ----------------------------------------------------- */
      when pos("*",ldsname) > 0 then do
        if left(ldsname,1) = "'" then
        ldsname = substr(ldsname,2,length(ldsname)-2)
        if right(ldsname,2) = ".*" then do
          ldsname = ldsname"*"
        end
        multiple = "on"
      end
      otherwise nop
    end

    /* -------------------------- *
    * Find remote member ?       *
    * -------------------------- */
    if length(rdsname) > 0 then rdsnamex = rdsname
    if pos("(",rdsname) > 0 then do
      parse value rdsname with rdsnamex "(" to_mem ")"
      if left(rdsname,1) = "'" then
      rdsnamex = rdsnamex"'"
    end

    /* -------------------------- *
    * Set from dsname var        *
    * -------------------------- */
    if length(ldsnamex) > 0 then do
      from_dsn = ldsnamex
    end
    else do
      from_dsn = ldsname
      ldsnamex = ldsname
    end

    if pos("'",ldsnamex) > 0 then
    if pos("(",ldsnamex) > 0 then do
      parse value ldsname with "'" from_dsn "(" .
      from_dsn = "'"from_dsn"'"
    end
    Select
      When left(from_dsn,1) = "'" then nop
      When left(from_dsn,1) = "/" then nop
      When sysvar('syspref') <> null then nop
      When sysvar('syspref') = null then
      from_dsn = "'"from_dsn"'"
      Otherwise nop
    end

    if length(rdsnamex) > 0 then do
      to_dsn = rdsnamex
      rename = "on"
    end
    else if mvs = "Yes" then
    if pos(ftpgp,'GP') > 0 then do
      rdsnamex = ldsnamex
      to_dsn   = rdsnamex
      rdsnamex = rdsnamex
    end

    if pos("'",rdsnamex) > 0 then
    if pos("(",rdsnamex) > 0 then do
      parse value rdsnamex with "'" to_dsn "(" to_mem .
      to_dsn = "'"to_dsn"'"
    end
    /* ---- EHA MOD HFS ---- */
    /* no uppercase with translate command */
    /* if HFS file and MVS="yes"           */
    if substr(rdsnamex,2,1) = '/' then nop
    else
    do
      /* ---- EHA ------------ */
      if mvs = "Yes" then do
        if pos("\",rdsnamex) = 0 then
        if pos("/",rdsnamex) = 0 then do
          rdsnamex = translate(rdsnamex)
          to_dsn   = translate(to_dsn)
        end
      end   /* EHA ERROR* this end was missing */
    end
    if length(to_mem) > 0 then to_mem = translate(to_mem)

    /* -------------------------- *
    * Test status of the Local   *
    * data set.                  *
    * -------------------------- */
    if pos("\",ldsnamex) = 0 then
    if pos("/",ldsnamex) = 0 then
    if multiple = null then do
      /* ---- EHA ADD HFS ---- */
      /* check if file exist   */
      /* when it is a HFS file */
      if substr(ldsnamex,2,1) = '/' then do
        path = ldsnamex
        path = STRIP(path,,"'")
        x = syscalls('ON')      /* Z/OS REX/UNIX */
        address syscall
        "lstat (path) st."
        /* lstat--pathname--stem
        lstat invokes the lstat callable service
        to obtain status information about a file.  */
        x = syscalls('OFF')
        Address ISPEXEC     /* restore environment */
        if st.0 = 0 then do  /* 0 = notfound */
          zedsmsg = "Local HFS Error"
          zedlmsg = "HFS" path ,
            "Invalid Path or file not found"
          "Setmsg Msg(isrz001)"
          return
        end
      end
      /* ---- EHA ------------ */
      else do
        call listdsi ldsnamex 'dir'
        sysreason = sysreason /* remove leading zero's */
        if sysreason = 3 then do
          zdstota = 0; zds2ex = 0
          parse value null with zdsspc zdsdsnt zdsorg
          Address ISPExec "DSInfo Dataset("ldsnamex")"
          sysalloc   = strip(zdstota)
          sysseconds = strip(zds2ex)
          sp         = translate(left(strip(zdsspc),2))
          select
            when sp = "BL" then spx = "BLK"
            when sp = "TR" then spx = "TRK"
            when sp = "CY" then spx = "CYL"
            otherwise spx = sp
          end
          if strip(zdsdsnt) = "HFS"
          then sysdsorg  = strip(zdsdsnt)
          else sysdsorg  = strip(zdsorg)
          sysadirblk = 0
        end
        if sysreason = 8 then do
          sysdsorg = "PS"
          tape_fl  = 1
        end
        if sysreason = 5 then do
          zedsmsg = "From DSN Error"
          zedlmsg = "DSN" ldsname ,
            "Invalid dsname or dsname not found"
          "Setmsg Msg(isrz001)"
          return
        end
        if length(members) > 0 then do
          dsn_stat = sysdsn(ldsnamex)
          if dsn_stat <> "OK" then do
            zedsmsg = "From DSN Error"
            zedlmsg = "DSN:" ldsname dsn_stat
            "Setmsg msg(isrz001)"
            return
          end
        end
      end
    end
  end

  /* -------------------------- *
  * Check remote Hostname      *
  * -------------------------- */
  shost = thost
  if thost = "?" then call get_hostname
  zcmd = null
  if savepwd = 1 then
  "Vput (password passwvfy) Profile"

  if thost = "?" then thost = "*****"

  /* ---------------------------------------------------------- *
  * Build password for anonymous connections using the current *
  * userid and hostname.                                       *
  * ---------------------------------------------------------- */
  if userid = "anonymous" then
  if length(password) = 0 then do
    res= Socket('Initialize','ANYNAME')
    xhost=      Socket('GetHostId')
    phost = Socket('GetHostByAddr',word(xhost,2))
    res= Socket('Terminate')
    password = sysvar('sysuid')"@"word(phost,2)
    "Addpop"
    "Display Panel(ftpbanon)"
    "Rempop"
  end

  call setup_jcl

  /* ------------------------- *
  | Perform the GET operation |
  * ------------------------- */
  if ftpgp = 'G' then do
    call do_get
    return
  end

  /* -------------------------- *
  * If the pds is a pdse then  *
  * set directory blocks = to  *
  * members/3 for ftp.         *
  * -------------------------- */
  tdpdse = 0
  if sysadirblk = "NO_LIM" then do
    sysadirblk = 'PDSE'
    tdpdse = 1
  end

  parse value sysadirblk with sysadirblk '.' .

  select
    when sysunits = "TRACK"    then do
      space = "TRK"
      sp    = "TR"
    end
    when sysunits = "CYLINDER" then do
      space = "CYL"
      sp    = "CY"
    end
    when sysunits = "BLOCK"    then do
      space  = sysblksize
      sp     = "Blocks"
    end
    otherwise do
      space = "TRK"
      sp    = "TR"
    end
  end

  if sp = "TR" then site_sp = "Tracks"
  else site_sp = sp

  /* -------------------------- *
  * Set remote dsname          *
  * -------------------------- */
  if length(to_dsn) = 0 then
  if ftpgp /= 'S' then do
    if mvs = "Yes"
    then targ_dsn = from_dsn
    else targ_dsn = to_dsn
  end
  if length(to_dsn) > 0
  then targ_dsn = to_dsn
  else targ_dsn = null

  slash = null
  Select
    When left(targ_dsn,1) = "'" then nop
    When pos('/',targ_dsn) > 0  then slash = "/"
    When pos('\',targ_dsn) > 0  then slash = "\"
    When sysvar('syspref') <> null then nop
    When sysvar('syspref') = null then
    targ_dsn = "'"whlq"."targ_dsn"'"
    otherwise nop
  end

  if sysalloc = null then do
    sysalloc = 1
    sysseconds = 1
  end
  parse value sysalloc*1.5 with sysalloc'.'.
  balloc = "("sysalloc","sysseconds")"
  palloc = "("sysalloc","sysseconds")"
  if tdpdse = 0
  then direct = sysadirblk
  else direct = null
  /* ---- EHA ADD HFSX ---- */
  /* modify sysdsorg (listdsi) if HFSX File */
  /* HFSX is to handle HFS files */
  if substr(ldsnamex,2,1) = '/' then sysdsorg = "HFSX"
  /* ---- EHA ------------ */

  /* -------------------------- *
  * Setup for PDS Member Xfer  *
  * But first check the        *
  * Check for dsorg types      *
  * -------------------------- */
  Select
    When multiple = "on" then do
      zcmd = "REFRESH"
      do until zcmd = null
        call Do_Pattern
      end
      zcmd = null
      if cancel = 1 then call start
      if lrc <> 0 then do
        zedsmsg = null
        zedlmsg = "No datasets match pattern:" ldsname,
          "a dsname pattern must have a valid hlq."
        "Setmsg msg(isrz000)"
        call start
      end
      unl = "Yes"
      dss = "Yes"
      "Display Panel(ftpbpdss)"
      /* --------------------------- *
      * change the primary and      *
      * secondary allocations in    *
      * balloc to suite your site   *
      * and general usage for.      *
      * --------------------------- */
      balloc     = "("mult_space","mult_space")"
      sysalloc   = mult_space
      sysseconds = mult_space
      call build_dump
    end
    When wordpos(sysdsorg,"VS HFS") > 0 then do
      unl = "Yes"
      dss = "Yes"
      "Display Panel(ftpbpdss)"
      call build_dump
    end
    When sysdsorg = "DA" then do
      unl = "Yes"
      dss = "Yes"
      "Display Panel(ftpbpdss)"
      call build_dump
    end
    When sysrecfm = "VBS" then do
      unl = "Yes"
      dss = "Yes"
      "Display Panel(ftpbpdss)"
      call build_dump
    end
    When sysdsorg = "PO" then do
      if sysrecfm <> "U" then
      unl = "No"
      if ftpgp = 'S' then do /* Sync */
        call set_ftp
        call do_local_jcl
        call do_sync
        return
      end
      call do_members
      if mem_err = 1 then do
        zedsmsg = "*Error*"
        zedlmsg = "No members found to match specified",
          "pattern:" mems
        "Setmsg Msg(isrz001)"
        return
      end
      if mem_err = 2 then do
        zedsmsg = "*Error*"
        zedlmsg = "No members selected.  Try again."
        "Setmsg Msg(isrz001)"
        if loadjcl_dsn_flag = 1 then do
          x=msg("off")
          Address TSO
          "Free F(Reload)"
          "Delete '"hlq"."loadjcl_dsn"'"
          Address ISPExec
        end
        return
      end
      if mem_err = 3 then return
    end
    When pos(slash,from_dsn) > 0 then do
      if left(from_dsn,1) = "'" then
      from_dsn = substr(from_dsn,2,length(from_dsn)-2)
      if targ_dsn <> null then
      if left(targ_dsn,1) = "'" then
      targ_dsn = substr(targ_dsn,2,length(targ_dsn)-2)
      unl = "No"
      call set_ftp
      if targ_dsn <> null then
      call set_cd
      pslsl = 0
      do forever
        psl = pos(slash,from_dsn,pslsl+1)
        if psl > 0 then pslsl = psl
        if psl = 0 then leave
      end
      psloc = left(from_dsn,pslsl)
      from_dsn = substr(from_dsn,pslsl+1)
      nn      = ftp.0 + 1
      ftp.nn = "lcd" psloc
      nn     = nn + 1
      if pos(slash,targ_dsn) > 0 then do
        pslsl = 0
        do forever
          psl = pos(slash,targ_dsn,pslsl+1)
          if psl > 0 then pslsl = psl
          if psl = 0 then leave
        end
        psloc = left(targ_dsn,pslsl)
        targ_dsn = substr(targ_dsn,pslsl+1)
        ftp.nn = "mkdir" psloc
        nn     = nn + 1
        ftp.nn = "cd" psloc
        nn     = nn + 1
      end
      if from_dsn = "*" then
      ftp.nn = "Mput *"
      else
      if from_dsn = targ_dsn then
      ftp.nn = "Put" from_dsn
      else do
        if length(from_dsn) + length(targ_dsn) < 50 then
        ftp.nn = "Put" from_dsn targ_dsn
        else do
          ftp.nn = "Put" from_dsn "+"
          nn = nn + 1
          ftp.nn = targ_dsn
        end
      end
      ftp.0 = nn
    end
    When sysdsorg = "PS" then do
      parse value "" with tunit tvol
      call set_ftp
      if targ_dsn <> null then
      call set_cd
      if tape_fl = 1 then do
        if tunit = null then tunit = tape
        "Display Panel(ftpbsite)"
        if pri <> null then sysalloc   = pri
        if sec <> null then sysseconds = sec
        if sp  <> null then site_sp    = sp
        if length(sysrecfm) + length(syslrecl),
          + length(blk) > 0 then do
          nn = ftp.0 + 1
          ftp.nn = "Site"
          ftp.0 = nn
          if sysrecfm <> null then ftp.nn = ftp.nn ,
            "Recfm="sysrecfm
          if syslrecl <> null then ftp.nn = ftp.nn ,
            "LRecl="syslrecl
          if blk <> null then ftp.nn = ftp.nn ,
            "Blksize="blk
        end
        if length(tdclas) > 0 then dsc = "DATAC="tdclas
        else dsc = null
        if length(tmclas) > 0 then mc = "MG="tmclas
        else mc = null
        if length(tsclas) > 0 then sc = "STOR="tsclas
        else sc = null
        if length(dsc) + length(mc) + length(sc) > 0 then do
          nn = ftp.0 + 1
          ftp.nn = "Site" mc sc dsc
          ftp.0 = nn
        end
      end
      nn = ftp.0 + 1
      if mvs = "Yes" then do
        ftp.nn = "Site "
        if sysalloc <> null then ftp.nn = ftp.nn ,
          "pri="sysalloc
        if sysseconds <> null then ftp.nn = ftp.nn ,
          "sec="sysseconds
        if site_sp <> null then ftp.nn = ftp.nn site_sp
        if tvol    <> null then ftp.nn = ftp.nn "Volume="tvol
        if tunit   <> null then ftp.nn = ftp.nn "Unit="tunit
        nn = nn + 1
      end
      if from_dsn = targ_dsn then
      ftp.nn = "Put" from_dsn
      else do
        if length(from_dsn) + length(targ_dsn) < 50 then
        ftp.nn = "Put" from_dsn targ_dsn
        else do
          ftp.nn = "Put" from_dsn "+"
          nn = nn + 1
          ftp.nn = targ_dsn
        end
      end
      ftp.0 = nn
      unl   = "No"
    end
    /* ---- EHA ADD HFS ---- */
    /* prepare job for HFSX  */
    When sysdsorg = "HFSX" then do
      call set_ftp
      path = ldsnamex
      path = STRIP(path,,"'")
      pos = LASTPOS('/',path)
      pos = pos - 1
      root = substr(path,1,pos)
      nn = ftp.0 + 1
      ftp.nn = "CWD "root
      nn = nn + 1
      ftp.nn = "Put" from_dsn to_dsn
      ftp.0 = nn
      unl   = "No"
    end
    /* ---- EHA ------------ */
    Otherwise do
      zedsmsg = "*Error*"
      zedlmsg = ldsname "is an unsupported file type",
        "of" sysdsorg
      "Setmsg Msg(isrz001)"
      return
    end
  end

  /* -------------------------- *
  * Closing FTP instructions   *
  * -------------------------- */
  nn = ftp.0 + 1
  if length(post) > 0 then do
    ftp.nn = post
    nn = nn + 1
  end
  ftp.nn = "Close"
  nn = nn + 1
  ftp.nn = "Quit"
  nn = nn + 1
  ftp.nn = "/*"
  if unl = "Yes" then do
    call set_ftpget_jcl
    if ftpif = 1 then do
      nn = nn + 1
      ftp.nn = "//    ENDIF"
      ftpif = 0
    end
    nn = nn + 1
    ftp.nn = "//DELSTEP   EXEC PGM=IEFBR14"
    nn = nn + 1
    ftp.nn = "//DELLOAD   DD  DISP=(OLD,DELETE),"
    nn = nn + 1
    ftp.nn = "//          DSN="hlq"."loadjcl_dsn
    ftp.nn = translate(ftp.nn)
    nn = nn + 1
    ftp.nn = "//DELULOAD  DD  DISP=(OLD,DELETE),"
    nn = nn + 1
    ftp.nn = "//          DSN="hlq"."unload_dst
    ftp.nn = translate(ftp.nn)
    nn = nn + 1
    ftp.nn = "/*"
  end
  ftp.0 = nn

  /* ------------------------------------------------------ *
  * Now if unl is 'Yes'  go build the jcl to print the job *
  * that was submitted and executed at the remote site.    *
  * ------------------------------------------------------ */
  if unl = "xxx" then do
    call set_ftpget_jcl
    if ftpif = 1 then do
      nn = ftp.0 + 1
      ftp.nn = "//    ENDIF"
      ftpif = 0
    end
    ftp.0 = nn
  end /* if unload */

  /* ---------------------------------------------------------- *
  * Display for Edit, Browse, Submit or eXecute the generated  *
  * JCL and FTP control statements.                            *
  * ---------------------------------------------------------- */

  if thost <> "*****" then do
    /* -------------------------- *
    * Create local jcl           *
    * -------------------------- */
    rwlj = 1
    call do_local_jcl

    /* -------------------------- *
    * Create remote jcl          *
    * -------------------------- */
    if unl = "Yes" then do
      rwrj = 1
      call do_remote_jcl
    end
  end

  ftprfind = null
  "Vput ftprfind"

  /* ---------------------------------------------------------- *
  * Begin the transfer process.                                *
  *                                                            *
  * if mhost is not null then we have multiple remote hosts    *
  * ---------------------------------------------------------- */
  if mhst = null then do
    Call do_ftp
  end
  else do
    /* ------------------------------------------------------ *
    * Process each host selection                            *
    * ------------------------------------------------------ */
    do hn = 1 to words(mhst)
      phost = thost
      parse value word(mhst,hn) with thost":"thport":"tls
      call Fix_FTP
      call Do_FTP
    end
  end

  Return

  /* ----------------------------------------------------------- *
  * Alloc and write generated jcl to vio data set for browse,   *
  * edit, submit, or eXecute.                                   *
  *                                                             *
  * Note: the password is only included in the submitted file.  *
  * ----------------------------------------------------------- */
do_local_jcl:
  if rwlj = 0 then return
  if ddn <> null then do
    "LMFree dataid("dataid")"
    dataid = null
    x=msg("off")
    Address TSO "Free  f("ddn")"
  end
  ddn = "FTP"random()
  Call set_netrc
  Address TSO
  "Alloc f("ddn") new Unit("vio") spa(15,15) tr" ,
    "Recfm(F b) Lrecl(80) Blksize(0) Reuse"
  "Execio * diskw" ddn "(Finis stem ftp."
  Address ISPExec
  "Lminit Dataid(dataid) DDName("ddn")"
  return

  /* -------------------------- *
  * Write out reload jcl dsn   *
  * -------------------------- */
do_remote_jcl:
  if rwrj = 0 then return
  if unl = "No" then return
  Address TSO
  if loadjcl_dsn_flag = 1 then do
    x=msg("off")
    "Free F(Reload)"
    "Delete '"hlq"."loadjcl_dsn"'"
  end
  "Alloc f(Reload) new Unit("dasd") spa(1,1) tr Recfm(F b)" ,
    "Lrecl(80) Blksize(0) Reuse ds('"hlq"."loadjcl_dsn"')"
  "Execio * diskw reload (Finis Stem load."
  "Free  f(Reload)"
  loadjcl_dsn_flag = 1
  Address ISPExec
  return

Do_Pds:
  if translate(mvs) = 'SYNC' then do
    call do_sync
    return
  end
  mems = members
  if do_pds_flag = 1 then return
  "Lminit Dataid(dataid) Dataset("from_dsn") Enq(Shr)"
  "Lmopen Dataid("dataid") Option(Input)"
  zllcmd = null; zlmember = null
  Select
    when pos("*",members) = 0 then
    "Lmmdisp Dataid("dataid") Option(Display)",
      "Commands(Any) Panel(FTPBM)"
    when pos("*",members) > 0 then do
      call build_list
      if rc <> 4 then
      "Lmmdisp Dataid("dataid") Option(Display)",
        "Commands(Any) Panel(FTPBM) Member("members")"
    end
    otherwise nop;
  end

  do while rc == 0
    Call process_selection
    "Lmmdisp Dataid("dataid") Option(Get)"
    if rc == 8
    then "Lmmdisp Dataid("dataid") Option(Display)",
      "Commands(Any) Panel(FTPBM)"
  end
  "Lmmdisp Dataid("dataid") Option(Free)"
  "Lmclose Dataid("dataid")"
  "Lmfree  Dataid("dataid")"
  dataid = null
  /* -------------------------- *
  * drop pattern member if > 1 *
  * or replace members w/all   *
  * -------------------------- */
  if words(members) = 1 then do
    if members = "*"
    then members = null
    if pos("*",members) > 0 then do
      if nomemopt = 1 then do
        mem_err = 2
        return
      end
      members = all_mem
    end
  end
  else do
    member_count = words(members)
    new_mem = null
    do mx = 1 to member_count
      if pos("*",word(members,mx)) = 0
      then new_mem = new_mem word(members,mx)
    end
    members = new_mem
  end
  do_pds_flag = 1
  return

Process_Selection:
  if left(from_dsn,1) = "'"
  then parse value from_dsn with "'" w_dsn "'"
  else w_dsn = sysvar("syspref")"."from_dsn
  zlmember = strip(zlmember)
  Select
    When zllcmd = "/" | zllcmd = "S"
    Then do
      "Lmmdisp Dataid("dataid") Option(Put) Member("zlmember")",
        "Zludata(selected)"
      call do_sel zlmember
    end
    When zllcmd = "\" | zllcmd = "U"
    Then do
      "Lmmdisp Dataid("dataid") Option(Put) Member("zlmember")"
      call do_usel zlmember
    end
    When zllcmd = "B"
    Then "Browse Dataid("dataid") Member("zlmember")"
    Otherwise nop;
  End
  return

Do_Sel:
  /* first make sure we don't already have it */
  if wordpos(zlmember,members) > 0 then return
  /* now add it into our list */
  members = strip(members zlmember)
  return

Do_Usel:
  p = wordpos(zlmember,members)
  if p > 0 then
  members = delword(members,p,1)
  return

  /* -------------------------- *
  * Get a unique jobid by      *
  * bumping the last char      *
  * -------------------------- */
Get_JobID:
  "VGET (JOBSUF) PROFILE"
  if length(jobsuf) = 0 then jobsuf = "A"
  else
  jobsuf = translate(jobsuf, ,
    'BCDEFGHIJKLMNOPQRSTUVWXYZ1234567890A', ,
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
  "VPUT (JOBSUF) PROFILE"
  return

Do_Members:
  mem_err = 0
  /* --------------------------------------------------------- *
  * Test for MVS transfer or not.                             *
  *                                                           *
  * If MVS transfer then display prompt for PDS create or     *
  * replace , unload, and sysut3 allocation.                  *
  * --------------------------------------------------------- */
  if mvs = "No" then
  if unl = null then do
    new = "No"
    unl = "No"
  end

  if mvs = 'Yes' then do
    x = check_remote_dataset(targ_dsn)
    if x = 4 then do
      zedsmsg = 'Cancelled.'
      zedlmsg = 'You have cancelled the FTP request.'
      'setmsg msg(isrz001)'
      mem_err = 3
      return
    end
    if x = 2 then do
      zedsmsg = 'Error.'
      zedlmsg = 'You have not provided a valid userid/password to' ,
        'connect to the remote system.'
      'setmsg msg(isrz001)'
      mem_err = 3
      return
    end
    if x = 3 then do
      zedsmsg = 'Error.'
      zedlmsg = 'You have not provided a valid remote hostname or' ,
        'I.P. address.'
      'setmsg msg(isrz001)'
      mem_err = 3
      return
    end
  end

  Select
    when unl = "No" then do
      call set_ftp
      put = "Put "
      putr = ""
      nn = ftp.0
      if mvs = "Yes" then do
        if new = "Yes" then do
          Call ftp_site_info
          if dln = "Yes" then do
            nn = nn + 1
            ftp.nn = "Delete" targ_dsn
          end
          nn = nn + 1
          ftp.nn = "Site recfm="sysrecfm "lrecl="syslrecl ,
            " blksize="blk
          nn = nn + 1
          if tdpdse = 1 then  /* eha 19/01/2009 */
          Do
            ftp.nn = "Site Pdstype=pdse"
            nn = nn + 1
          End
          if tdpdse = 0 then direct = 'Directory='direct
          else direct = null
          ftp.nn = "Site pri="sysalloc "sec="sysseconds ,
            direct site_sp
          if length(tunit) > 0 then ns = "Unit="tunit
          else ns = null
          if length(tvol) > 0 then nv = "Volume="tvol
          else nv = null
          if length(tdclas) > 0 then dsc = "DATAC="tdclas
          else dsc = null
          if length(tmclas) > 0 then mc = "MG="tmclas
          else mc = null
          if length(tsclas) > 0 then sc = "STOR="tsclas
          else sc = null
          if length(ns) + length(nv) + length(dsc) ,
            + length(mc) + length(sc) > 0 then do
            nn = nn + 1
            ftp.nn = "Site" ns nv mc sc dsc
          end
          nn = nn + 1
          ftp.nn = "MKDir" targ_dsn
        end
      end
      nn = nn + 1
      ftp.nn = "lcd" from_dsn
      ftp.0 = nn
      if targ_dsn <> null then
      call set_cd
      if mvs <> "Yes" then
      if length(targ_dsn) > 0 then do
        if new = "Yes" then do
          nn = nn + 1
          ftp.nn = "MKDir" targ_dsn
        end
        if members = "*" then do
          nn = nn + 1
          ftp.nn = "cd" targ_dsn
        end
      end
      ftp.0 = nn
    end
    When unl = "Yes" then do
      call build_iebcopy
    end
    Otherwise nop
  end

  Select
    When members = "*" then
    if unl = "No" then do
      'AddPop Row(5) Column(10)'
      'display panel(ftpbunld)'
      drc = rc
      'rempop'
      if drc > 0 then do
        if drc = 8 then do
          zedsmsg = 'Canceled.'
          zedlmsg = 'FTP Sync canceled.'
          'setmsg msg(isrz001)'
        end /* if 8 */
        else do
          zedsmsg = zerrsm
          zedlmsg = zerrlm
        end /* else */
        mem_err = 3
        return
      end /* if drc */
      if ftpbunld = 'Y' then do
        unl = 'Yes'
        ftp.0 = ftpstep - 1
        call build_iebcopy
      end
      else do
        nn     = ftp.0 + 1
        ftp.nn = "mput *"
        ftp.0  =  nn
      end
    end
    When pos("*",members) > 0 then do
      call do_pds
      If unl = "No" then
      do i = 1 to words(members)
        nn = ftp.0 + 1
        ftp.nn = put""word(members,i)""putr
        ftp.0 = nn
      end
      If words(members) = 0 then
      if unl = "No" then do
        nn     = ftp.0 + 1
        ftp.nn = "Mput *"
        ftp.0  = nn
        if nomemopt = 1 then do
          mem_err = 2
          return
        end
        zedsmsg = ""
        zedlmsg = "*** No members selected so ALL assumed ***"
        "Setmsg Msg(isrz001)"
      end
    end
    When words(members)  = 1 then
    if unl = "No" then do
      nn = ftp.0 + 1
      if length(to_mem) = 0 then
      ftp.nn = put""members""putr
      else
      ftp.nn = "put" members to_mem
      ftp.0 = nn
    end
    When length(members) = 0 then do
      call do_pds
      if unl = 'No' then
      if words(members) > pds_unld | strip(members) = null
      then do
        'AddPop Row(5) Column(10)'
        'display panel(ftpbunld)'
        drc = rc
        'rempop'
        if drc > 0 then do
          if drc = 8 then do
            zedsmsg = 'Canceled.'
            zedlmsg = 'FTP Sync canceled.'
            'setmsg msg(isrz001)'
          end /* if 8 */
          else do
            zedsmsg = zerrsm
            zedlmsg = zerrlm
          end /* else */
          mem_err = 3
          return
        end /* if drc */
        if ftpbunld = 'Y' then do
          unl = 'Yes'
          ftp.0 = ftpstep - 1
          call build_iebcopy
        end
      end
      if words(members) = 0 then
      if nomemopt = 1 then do
        mem_err = 2
        return
      end
      If unl = "No" then
      do i = 1 to words(members)
        nn = ftp.0 + 1
        ftp.nn = put""word(members,i)""putr
        ftp.0 = nn
      end
      If words(members) = 0 then
      if unl = "No" then do
        nn     = ftp.0 + 1
        ftp.nn = "Mput *"
        ftp.0  = nn
        zedsmsg = ""
        zedlmsg = "*** No members selected so ALL assumed ***"
        "Setmsg Msg(isrz001)"
      end
    end
    Otherwise nop;
  end
  return

  /* -------------------------- *
  * Build list of all members  *
  * that match the pattern.    *
  * -------------------------- */
Build_List:
  Parse value "" with all_mem  amem mem_err
  "Lminit Dataid(buildid) Dataset("from_dsn") Enq(Shr)"
  "Lmopen Dataid("buildid") Option(Input)"
  do forever
    "LmmList Dataid("buildid") Option(List) Member(amem)",
      "Pattern("members")"
    if rc > 7 then leave
    if rc = 4 then do
      mem_err = 1
      "Lmclose Dataid("buildid")"
      "Lmfree  Dataid("buildid")"
      buildid = null
      return
    end
    all_mem = all_mem amem
  end
  "Lmclose Dataid("buildid")"
  "Lmfree  Dataid("buildid")"
  buildid = null
  return

Set_FTP:
  nn = ftp.0 + 1
  if unl = 'Yes' then do
    ftp.nn = "//   IF  ^ABEND && UNLOAD.RC <= 4 THEN"
    ftpif = 1
    nn = nn + 1
  end
  if mhst /= null then
  parse value strip(mhst) with thost":"thport":"tls .
  if tls = 'Yes'
  then tlso = '-a tls '
  else tlso = ''
  if fir = 'Yes'
  then do
    ftpparm = strip(tlso''firewall) "(EXIT"
    ftp.nn = ,
      "//FTPSTEP  EXEC PGM=FTP,PARM='"ftpparm"'"
    ftpstep = nn
  end
  else do
    ftpparm = strip(tlso thost thport) "(EXIT"
    ftp.nn = ,
      "//FTPSTEP  EXEC PGM=FTP,PARM='"ftpparm"'"
    ftpstep = nn
  end
  nn = nn + 1
  ftp.nn = "//SYSPRINT  DD  SYSOUT=*"
  if steplib <> null then do
    nn = nn + 1
    ftp.nn = "//STEPLIB   DD  DISP=SHR,DSN="steplib
  end
  if sysftpd = 1 then do
    nn = nn + 1
    ftp.nn = "//SYSFTPD   DD  DISP=SHR,DSN="sysftpds
  end
  if systcpd = 1 then do
    nn = nn + 1
    ftp.nn = "//SYSTCPD   DD  DISP=SHR,DSN="systcpds
  end

  if netrc = 1 then do
    if usernrc = null then do
      nn = nn + 1
      ftp.nn = ,
        "//* The NETRC Dataset will be allocated with the Submit dialog"
      nn = nn + 1
      ftp.nn = ,
        "//* option to protect your password."
      nn = nn + 1
      ftp.nn = "//NETRC     DD  DISP=(OLD,DELETE,DELETE),"
      nn = nn + 1
      ftp.nn = "//          DSN="netrc_dsn
    end
    else do
      nn = nn + 1
      ftp.nn = "//NETRC     DD  DISP=SHR,DSN="usernrcl
    end
    netrc_dd = nn

    if fir = 'No' then
    id = userid;
    else if fir = 'Yes' then do
      if FirIDwH = 0 then do
        id = userid"@"thost;
      end
      else do
        id = userid;
      end
    end
    if fir = "Yes" then
    pw = password
    else
    pw = password
    Address ISPExec
  end

  /* ----------------------------------------------------- *
  * Now create the //INPUT  DD                            */
  nn = nn + 1
  ftp.nn = "//INPUT     DD  *"

  if netrc = 0 then do
    if fir = 'Yes' then do
      if FirIDwH = 0 then do
        nn = nn + 1
        ftp.nn = userid"@"thost;
      end
      else do
        nn = nn + 1
        ftp.nn = thost;
        nn = nn + 1
        ftp.nn = userid;
      end
    end
    nn = nn + 1
    ftp_password = left('@',length(password),'@')
    if fir = "Yes" then
    ftp.nn = ftp_password
    else
    ftp.nn = userid ftp_password
  end

  ftp.0 = nn
  if translate(psv) = 'YES' then do
    nn = ftp.0 + 1
    ftp.nn = 'locsite fwfriendly epsv4'
    ftp.0 = nn
  end
  if length(other) > 0 then do
    nn = ftp.0 + 1
    ftp.nn = other
    ftp.0 = nn
  end
  if bin = "Yes" then do
    nn = ftp.0 + 1
    ftp.nn = "Binary"
    ftp.0 = nn
  end

  if sysdsorg = "VS" then do
    nn = ftp.0 + 1
    ftp.nn = "mode b"
    nn = nn + 1
    ftp.nn = "type e"
    ftp.0 = nn
  end
  else
  if mvs = "Yes" then do
    nn = ftp.0 + 1
    ftp.nn = "type e"  /* set type ebcdic */
    nn = nn + 1
    ftp.nn = "mode b"  /* set block mode transfer */
    ftp.0 = nn
  end
  return

  /* ---------------------------------------------------- *
  * If the remote name contains directories              *
  * change to each one in turn, before putting the file. *
  * ---------------------------------------------------- */
Set_CD:
  nn = ftp.0
  select
    when sysdsorg = "PO" then tdsn = 0
    when right(targ_dsn,1) = slash then tdsn = 0
    otherwise tdsn = 1
  end
  if left(targ_dsn,1) = slash then do
    nn = nn + 1
    ftp.nn = "cd" slash
  end
  targ_dsn = translate(targ_dsn," ",slash)
  tdw = words(targ_dsn)
  do td = 1 to tdw-1
    nn = nn + 1
    ftp.nn = "cd" word(targ_dsn,td)
  end
  if tdsn = 1 then do
    tdw = words(targ_dsn)
    targ_dsn = word(targ_dsn,tdw)
  end
  else do
    nn = nn + 1
    ftp.nn = "cd" word(targ_dsn,tdw)
  end
  ftp.0 = nn
  return

Set_FTPGet_JCL:
  parse source x y xcmd dd .
  Address TSO
  call get_dsn dd xcmd
  Address ISPExec
  execlib = return_dsn
  nn = ftp.0 + 1
  ftp.nn = "//PRINT     EXEC PGM=IKJEFT1B,"
  nn = nn + 1
  ftp.nn = "//    PARM='%FTPBJOB2 "ftprpt_dsn"'"
  nn = nn + 1
  ftp.nn = "//SYSEXEC   DD  DISP=SHR,DSN="execlib
  nn = nn + 1
  ftp.nn = "//REPORT    DD  SYSOUT=*,DCB=(RECFM=VBA,LRECL=255)"
  nn = nn + 1
  ftp.nn = "//SYSTSPRT  DD  SYSOUT=*,DCB=(RECFM=VB,LRECL=255)"
  nn = nn + 1
  ftp.nn = "//SYSTSIN   DD  DUMMY"
  nn = nn + 1
  ftp.nn = "/*"
  ftp.0 = nn
  return

Build_IEBCOPY:
  put = "  S M=("
  putr = ")"

  call set_unl_load

  if left(from_dsn,1) <> "'"
  then call fix_send_dsn
  else send_dsn = translate(from_dsn)
  call build_del_step
  nn = ftp.0 + 1
  ftp.nn = "//UNLOAD   EXEC PGM=IEBCOPY"
  nn = nn + 1
  ftp.nn = "//SYSPRINT  DD  SYSOUT=*"
  nn = nn + 1
  ftp.nn = "//INPUT     DD  DISP=SHR,DSN="strip(send_dsn,,"'")

  if new = "Yes" then
  call ftp_site_info
  else do
    if sdb = 0 then blk = 0
    else blk = sysblksize
    if sp = "Blocks" then blk = sysblksize
  end

  if big_load = "Y" then do
    nn = nn + 1
    ftp.nn = "//TEMP      DD  UNIT="dasd",DISP=(,DELETE),"
    nn = nn + 1
    ftp.nn = "//          DCB=(RECFM="sysrecfm",LRECL="syslrecl","
    nn = nn + 1
    ftp.nn = "//          BLKSIZE="blk"),"
    nn = nn + 1
    ftp.nn = "//          SPACE=("space","palloc",RLSE)"
  end
  nn = nn + 1
  ftp.nn = "//OUTPUT    DD  DISP=(,CATLG),UNIT="dasd","
  nn = nn + 1
  ftp.nn = "//          DSN="unload_dsn","
  nn = nn + 1
  if pos(word(space,1),"TRKCYL") = 0 then spx = blk
  else spx = word(space,1)
  if spx = 0 then spx = 27998
  ftp.nn = "//          SPACE=("spx","balloc",RLSE)"
  if ut3 = "Yes" then do
    nn = nn + 1
    ftp.nn = "//SYSUT3    DD  UNIT=SYSDA,SPACE=(CYL,(50,50))"
  end
  nn = nn + 1
  ftp.nn = "//SYSIN     DD  *"
  nn = nn + 1
  if big_load = "Y" then
  ftp.nn = "  COPYMOD INDD=INPUT,OUTDD=TEMP,MAXBLK=27998"
  else ftp.nn = "  COPY INDD=INPUT,OUTDD=OUTPUT"
  ftp.0 = nn

  nn = load.0 + 1
  if new = "Yes" then do
    load.nn = "//DELOAD    EXEC PGM=IEFBR14"
    nn = nn + 1
    if left(targ_dsn,1) <> "'" then do
      if sysvar('syspref') = null then
      load.nn = "//DELOAD    DD  DSN="strip(targ_dsn,,"'")","
      else
      load.nn = "//DELOAD    DD  DSN="whlq"."strip(targ_dsn,,"'")","
    end
    else
    load.nn = "//DELOAD    DD  DSN="strip(targ_dsn,,"'")","
    load.nn = translate(load.nn)
    nn = nn + 1
    load.nn = "//          DISP=(MOD,DELETE),"
    nn = nn + 1
    load.nn = "//          UNIT="dasd",SPACE=(TRK,(0))"
    nn = nn + 1
  end

  load.nn = "//LOAD      EXEC PGM=IEBCOPY"
  nn = nn + 1
  load.nn = "//SYSPRINT  DD  SYSOUT=*"
  nn = nn + 1
  load.nn = "//INPUT     DD  DISP=(OLD,DELETE),"
  nn = nn + 1
  load.nn = "//          DSN="reload_dsn
  load.nn = translate(load.nn)
  if big_load = "Y" then do
    nn = nn + 1
    load.nn = "//TEMP      DD  DISP=(,DELETE),UNIT="dasd","
    nn = nn + 1
    load.nn = "//          SPACE=("word(space,1)","palloc",RLSE)"
  end
  nn = nn + 1
  if rdsname /= null
  then targ_dsn = rdsname
  else targ_dsn = ldsname
  if pos('(*)',targ_dsn) > 0 then do
    parse value targ_dsn with ld'(*)'rd
    targ_dsn = ld''rd
  end
  if left(targ_dsn,1) = "'" then
  load.nn = "//OUTPUT    DD  DSN="strip(targ_dsn,,"'")","
  else do
    if length(sysvar('syspref')) = 0 then
    load.nn = "//OUTPUT    DD  DSN="targ_dsn","
    else
    load.nn = "//OUTPUT    DD  DSN="whlq"."targ_dsn","
  end
  load.nn = translate(load.nn)
  nn = nn + 1
  if new = "No" then
  load.nn = "//          DISP=SHR"
  else do
    load.nn = "//          DISP=(,CATLG),"
    if length(tunit) > 0 then tun = tunit
    else tun = ""dasd""
    if length(tvol) > 0 then tvl = ",VOL=SER="tvol
    else tvl = null
    nn = nn + 1
    load.nn = "//          UNIT="tun""tvl","
    if tdpdse = 1 then do
      nn = nn + 1
      load.nn = "//          DSNTYPE=LIBRARY,DSORG=PO,"
      parse value palloc with '('p','s')'
      palloc = '('p','s',1)'
    end
    nn = nn + 1
    if blk = null then blk = 0
    load.nn = "//          DCB=(RECFM="sysrecfm,
      ||  ",LRECL="syslrecl",BLKSIZE="blk"),"
    nn = nn + 1
    if pos(word(space,1),"TRKCYL") = 0 then spx = blk
    else spx = word(space,1)
    if spx = 0 then spx = 32760
    if pos('direct=',space) > 0
    then do
      parse value sp with .'direct='dir
      palloc = "("sysalloc","sysseconds","dir")"
    end
    load.nn = "//          SPACE=("spx","palloc""rlse")"
  end
  if ut3 = "Yes" then do
    nn = nn + 1
    load.nn = "//SYSUT3    DD  UNIT=SYSDA,SPACE=(CYL,(100,50))"
  end
  nn = nn + 1
  load.nn = "//SYSIN     DD  *"
  if big_load = "Y" then do
    nn = nn + 1
    load.nn = " COPY INDD=INPUT,OUTDD=TEMP"
    nn = nn + 1
    load.nn = " COPYMOD INDD=((TEMP,R)),OUTDD=OUTPUT,MAXBLK="t
    nn = nn + 1
    load.nn = "/*"
  end
  else do
    nn = nn + 1
    load.nn = " COPY INDD=((INPUT,R)),OUTDD=OUTPUT"
    nn = nn + 1
    load.nn = "/*"
  end
  load.0 = nn

  select
    when length(members) = 0 then
    call do_pds
    when members = "*" then nop
    when pos("*",members) > 0 then
    call do_pds
    otherwise nop
  end

  nn = ftp.0

  Select
    When members = "*" then nop
    When words(members) = 1 then do
      nn = nn + 1
      if length(to_mem) = 0 then
      ftp.nn = put""strip(members)""putr
      else
      ftp.nn = put""members","to_mem""putr
    end
    When words(members) > 1 then
    do i = 1 to words(members)
      nn = nn + 1
      ftp.nn = put""word(members,i)""putr
    end
    Otherwise nop
  end

  if big_load = "Y" then do
    nn = nn + 1
    ftp.nn = "  COPY INDD=((TEMP,R)),OUTDD=OUTPUT"
    nn = nn + 1
    ftp.nn = "/*"
  end
  ftp.0 = nn

  call set_ftp

  nn = ftp.0 + 1
  ftp.nn = "Site pri="sysalloc "sec="sysseconds site_sp
  nn = nn + 1
  if sysvar('syspref') <> null then do
    if left(reload_dsn,1) = "'" then do
      ftp.nn = "Put '"unload_dsn"' +"
      nn = nn + 1
      ftp.nn = "    " reload_dsn
    end
    else do
      ftp.nn = "Put '"unload_dsn"' +"
      nn = nn + 1
      ftp.nn = "    '"reload_dsn"'"
    end
  end
  else do
    ftp.nn = "Put '"unload_dsn"' +"
    nn = nn + 1
    ftp.nn = "    '"reload_dsn"'"
  end
  nn = nn + 1
  ftp.nn = "Site pri=1 sec=1 Tracks"
  nn = nn + 1
  ftp.nn = "Put '"hlq"."loadjcl_dsn"' + "
  nn = nn + 1
  ftp.nn = "    '"whlq"."ftpjcl"'"
  nn = nn + 1
  ftp.nn = "mode s"
  nn = nn + 1
  ftp.nn = "Site filetype=jes"
  nn = nn + 1
  ftp.nn = "Locsite lrecl=255"
  nn = nn + 1
  ftp.nn = "get '"whlq"."ftpjcl"' +"
  nn = nn + 1
  ftp.nn = "    '"ftprpt_dsn"'"
  nn = nn + 1
  ftp.nn = "site filetype=seq"
  nn = nn + 1
  ftp.nn = "mode b"
  nn = nn + 1
  ftp.nn = "delete '"whlq"."ftpjcl"'"
  ftp.0 = nn
  if length(members) > 0 then do
    do_pds_flag = 1
  end
  return

build_dump:
  if left(from_dsn,1) <> "'"
  then call fix_send_dsn
  else send_dsn = translate(from_dsn)
  call set_unl_load
  call build_del_step
  nn = ftp.0 + 1
  ftp.nn = "//UNLOAD   EXEC PGM=ADRDSSU"
  nn = nn + 1
  ftp.nn = "//SYSPRINT  DD  SYSOUT=*"

  if multiple <> "on" then
  if sysdsorg = "VS" then do
    call find_vsam_space send_dsn
  end
  nn = nn + 1
  ftp.nn = "//OUTPUT    DD  DISP=(,CATLG),UNIT="dasd","
  nn = nn + 1
  ftp.nn = "//          DSN="unload_dsn","
  nn = nn + 1
  if sysdsorg = "VS" then
  ftp.nn = "//          SPACE=(TRK,"balloc",RLSE)"
  else
  ftp.nn = "//          SPACE=("space","balloc",RLSE)"
  nn = nn + 1
  ftp.nn = "//SYSIN     DD  *"
  nn = nn + 1
  ftp.nn = "  DUMP OUTDD(OUTPUT) - "

  if sysdsorg = "VS" then do
    nn = nn + 1
    ftp.nn = "       SPHERE - "
  end
  if vex = "No" then do
    nn = nn + 1
    ftp.nn = "       SHARE TOL(ENQF) -"
  end
  nn = nn + 1
  ftp.nn = "       HWCOMPRESS - "
  nn = nn + 1
  ftp.nn = "       OPTIMIZE(4)- "
  nn = nn + 1
  if multiple <> "on" then
  ftp.nn = "       DATASET(INCLUDE("strip(send_dsn,,"'")"))"
  else do
    if scnt + ecnt = 0 then do
      ftp.nn = "       DATASET(INCLUDE("strip(ldsname,,"'")"))"
    end
    /* -------------------------- *
    * Process Selected datasets  *
    * -------------------------- */
    if scnt > 0 then do
      in1 = 0
      ftp.nn = "       DATASET( -"
      if selected.0 > 0 then do
        do i = 1 to selected.0
          nn = nn + 1
          if in1 = 0 then do
            ftp.nn = "       INCLUDE("selected.i ", -"
            in1 = 1
          end
          else
          ftp.nn = "               "selected.i ", -"
        end
        nn = nn + 1
        ftp.nn = "       ))"
      end
    end
    /* -------------------------- *
    * Process Excluded datasets  *
    * -------------------------- */
    if ecnt > 0 then do
      in1 = 0
      ftp.nn = "       DATASET(INCLUDE("strip(ldsname,,"'")") -"
      if excluded.0 > 0 then do
        do i = 1 to excluded.0
          nn = nn + 1
          if in1 = 0 then do
            ftp.nn = "       EXCLUDE("excluded.i ", -"
            in1 = 1
          end
          else
          ftp.nn = "                "excluded.i ", -"
        end
        nn = nn + 1
        ftp.nn = "       ))"
      end
    end
  end
  ftp.0 = nn
  nn = load.0 + 1
  load.nn = "//LOAD     EXEC PGM=ADRDSSU"
  nn = nn + 1
  load.nn = "//SYSPRINT  DD  SYSOUT=*"
  nn = nn + 1
  load.nn = "//INPUT     DD  DISP=(OLD,DELETE,DELETE), "
  nn = nn + 1
  load.nn = "//          DSN="reload_dsn
  load.nn = translate(load.nn)
  if odddsn \= null then do
    nn = nn + 1
    load.nn = "//HERE      DD  DISP=SHR,DSN="odddsn
    load.nn = translate(load.nn)
  end
  nn = nn + 1
  load.nn = "//SYSIN     DD  *"
  nn = nn + 1
  load.nn = "  RESTORE INDD(INPUT) -"
  if sysdsorg = "VS" then do
    nn = nn + 1
    load.nn = "          SPHERE - "
  end
  if odymc <> null then do
    Select
      when abbrev('NONE',odymc,2) = 1 then mc = "NMC"
      otherwise mc = "MGMTCLAS("odymc")"
    end
    nn = nn + 1
    load.nn = "         " mc "- "
    load.nn = translate(load.nn)
  end
  if odysc <> null then do
    Select
      when abbrev('NONE',odysc,2) = 1 then sc = "NSC"
      otherwise sc = "STORCLAS("odysc")"
    end
    nn = nn + 1
    load.nn = "         " sc "- "
    load.nn = translate(load.nn)
  end
  if obpac \= null then do
    nn = nn + 1
    load.nn = "          BYPASSACS("obpac") - "
    load.nn = translate(load.nn)
  end
  if odddsn <> null then do
    nn = nn + 1
    load.nn = "          OUTDDNAME(HERE) - "
  end
  else if odyvol <> null then do
    nn = nn + 1
    load.nn = "          OUTDYNAM("odyvol") - "
    load.nn = translate(load.nn)
  end
  nn = nn + 1
  load.nn = "          CATALOG - "
  if vrp = "Yes" then do
    nn = nn + 1
    load.nn = "          REPLACE -"
  end
  if otenq = "Yes" then do
    nn = nn + 1
    load.nn = "          TOL(ENQF) -"
  end
  if vall = "All" then do
    nn = nn + 1
    load.nn = "          ALLDATA(*) -"
  end
  restore_dsn = strip(send_dsn,,"'")
  if rename = "on" then do
    nn = nn + 1
    if left(targ_dsn,1) = "'" then
    rename_dsn = strip(targ_dsn,,"'")
    else
    rename_dsn = hlq"."targ_dsn
    if multiple = "on" then do
      load.nn = "          RENAMEU("ldsname", - "
      nn      = nn + 1
      if left(rdsname,1) = "'" then
      rdsname = strip(rdsname,,"'")
      if right(ldsname,2) = '.*'
      then ldsname = ldsname'*'
      if right(ldsname,1) = '*' then
      Select
        When right(rdsname,2) = '.*' then
        rdsname = rdsname"*"
        When right(rdsname,3) = '.**' then nop
        Otherwise rdsname = rdsname'.**'
      end
      rt_dsn = translate(strip(rdsname,,"'"))
      load.nn = "                  "rt_dsn") -"
    end
    else do
      load.nn = "          RENAMEU("restore_dsn", - "
      nn      = nn + 1
      if right(rename_dsn,2) = ".*" then
      rename_dsn = rename_dsn"*"
      load.nn = "                  "rename_dsn") -"
    end
  end
  nn = nn + 1
  load.nn = "          DATASET(INCLUDE(**))"
  nn = nn + 1
  load.nn = "/*"
  load.0 = nn
  call set_ftp
  nn = ftp.0 + 1
  site_sp = "Tracks"
  ftp.nn = "Site pri="sysalloc "sec="sysseconds site_sp
  nn = nn + 1
  if sysvar('syspref') <> null then do
    if left(reload_dsn,1) = "'" then do
      ftp.nn = "Put '"unload_dsn"' +"
      nn = nn + 1
      ftp.nn = "     "reload_dsn
    end
    else do
      ftp.nn = "Put '"unload_dsn"' +"
      nn = nn + 1
      ftp.nn = "    '"reload_dsn"'"
    end
  end
  else do
    ftp.nn = "Put '"unload_dsn"' +"
    nn = nn + 1
    ftp.nn = "    '"reload_dsn"'"
  end
  nn = nn + 1
  ftp.nn = "Site pri=1 sec=1 Tracks"
  nn = nn + 1
  ftp.nn = "Put '"hlq"."loadjcl_dsn"' +"
  nn = nn + 1
  ftp.nn = "    '"whlq"."ftpjcl"'"
  nn = nn + 1
  ftp.nn = "mode s"
  nn = nn + 1
  ftp.nn = "Site filetype=jes"
  nn = nn + 1
  ftp.nn = "Locsite pri=15 sec=15 tracks lrecl=255"
  nn = nn + 1
  ftp.nn = "get '"whlq"."ftpjcl"'  +"
  nn = nn + 1
  ftp.nn = "    '"ftprpt_dsn"'"
  nn = nn + 1
  ftp.nn = "site filetype=seq"
  nn = nn + 1
  ftp.nn = "mode b"
  nn = nn + 1
  ftp.nn = "delete '"whlq"."ftpjcl"'"
  ftp.0 = nn
  if length(members) > 0 then do
    members = null
    do_pds_flag = 1
  end
  return

Build_Del_Step:
  nn = ftp.0 + 1
  ftp.nn = '/* '
  nn = nn + 1
  ftp.nn = '//PREDEL  EXEC PGM=IEFBR14'
  nn = nn + 1
  ftp.nn = '//DELDD   DD DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,'
  nn = nn + 1
  ftp.nn = '//           SPACE=(1,1),DSN='strip(unload_dsn,,"'")
  nn = nn + 1
  ftp.nn = '/* '
  ftp.0 = nn
  return

  /* -------------------------- *
  * Check for any migrated d/s *
  * for multiple (dss) xfers   *
  * -------------------------- */
Do_Pattern:
  parse value '' with cmdsn cmflag zcmd zsel action cancel

  t_dsn   = strip(ldsname,,"'")

  Address ISPEXEC
  "Lmdinit Listid(ftpb) Level("t_dsn")"
  lrc = rc

  tblname = "ftpb"random(9999)
  "TBCreate" tblname "names(zsel cmdsn action zdldsorg zdlsize zdlvol)" ,
    "Write"

  parse value 0 with 1 x_rc 1 scnt 1 ecnt 1 t_rc 1 mult_sels ,
    1 ztdtop

  "Control Display Lock"
  "Display Panel(ftpbpdsl)"

  do until x_rc > 0
    zdldsorg = null; zdlvol = null; zdlsize = 0
    "Lmdlist Listid("ftpb") Stats(YES) Dataset(cmdsn) Option(LIST)"
    x_rc = rc
    if x_rc = 0 then do
      "TBAdd" tblname
      scnt = scnt + 1
    end
  end
  "Lmdfree listid("ftpb")"

  if scnt = 0 then do
    "TBEnd" tblname
    cancel = 1
    zedsmsg = null
    zedlmsg = "Process Cancelled - no eligible datasets."
    "Setmsg msg(isrz001)"
    return
  end

  scnt = 0
  mult_sels = 0
  crp = 1
  rowcrp = 0
  last_find = 0

  "TBTop" tblname

  Do forever
    zcmd = null
    if mult_sels = 0 then do
      "TBTop" tblname
      "TBSkip" tblname "Number("crp")"
      if rowcrp = 0 then
      "TBDispl" tblname "Panel(ftpbsdsl)"
      else
      "TBDispl" tblname "Panel(ftpbsdsl)" ,
        "Csrrow("rowcrp") AutoSel(No)"
    end
    else
    "TBDispl" tblname
    t_rc = rc
    mult_sels = ztdsels
    if t_rc > 7 then leave
    if zcmd = "REFRESH" then leave
    if zcmd = "CANCEL" then leave
    if abbrev("FIND",word(zcmd,1),1)  = 1 then call do_find tblname
    if abbrev("RFIND",word(zcmd,1),1) = 1 then do
      zcmd = "RFIND" argument
      call do_find tblname
    end
    if zsel = "\" then zsel = "U"
    Select
      When zsel = "S" then do
        if cmflag = "E" then do
          zedsmsg = null
          zedlmsg = "Select and Exclude may not be",
            "used in the same transfer."
          "Setmsg msg(isrz001)"
          zsel = null
          "TBPut" tblname
        end
        else do
          cmflag = "S"
          if action = "Select" then leave
          scnt = scnt + 1
          action = "Select"
          zsel = null
          call listdsi "'"cmdsn"'" "Norecall"
          if sysreason = 9 then
          if left(zdlvol,6) = "MIGRAT" then
          Address TSO "HRecall '"cmdsn"'"
          if sysreason = 3 then do
            zdsvol = null
            Address ISPExec "DSInfo Dataset('"cmdsn"')"
            zdlvol = zdsvol
          end
          else if sysreason <> 9 then
          zdlvol = sysvolume
          "TBPut" tblname
          action = null
        end
      end
      When zsel = "E" then do
        if cmflag = "S" then do
          zedsmsg = null
          zedlmsg = "Exclude and Select may not be",
            "used in the same transfer."
          "Setmsg msg(isrz001)"
          zsel = null
          "TBPut" tblname
        end
        Else do
          cmflag = "E"
          ecnt = ecnt + 1
          action = "Exclude"
          zsel = null
          "TBPut" tblname
          action = null
        end
      end
      When zsel = "R" then do
        if action <> "Select" then
        action = "Recall"
        zsel = null
        call listdsi "'"cmdsn"'" "Norecall"
        if sysreason = 9 then
        if left(zdlvol,6) = "MIGRAT" then
        Address TSO "HRecall '"cmdsn"'"
        if sysreason <> 9 then
        zdlvol = sysvolume
        "TBPut" tblname
        action = null
      end
      When zsel = "M" then do
        if action = "Select" then do
          action = "Migrate"
          scnt = scnt - 1
          if scnt = 0 then cmflag = null
        end
        else action = "Migrate"
        zsel = null
        "TBPut" tblname
        action = null
        Address TSO "HMigrate '"cmdsn"'"
      end
      When zsel = "U" then do
        Select
          When left(action,1) = "E" then do
            ecnt = ecnt - 1
            if ecnt = 0 then cmflag = null
          end
          When left(action,1) = "S" then do
            scnt = scnt - 1
            if scnt = 0 then cmflag = null
          end
          Otherwise nop
        end
        action = ""
        zsel = null
        "TBPut" tblname
        action = null
      end
      Otherwise nop;
    end
  end

  if nodsnopt = 1
  then if scnt = 0
  then do
    zedsmsg = "Cancelled."
    zedlmsg = "No data sets selected."
    "Setmsg msg(isrz001)"
    cancel = 1
    return
  end

  "Control Display Lock"
  "Display Panel(ftpbpdsc)"

  if wordpos(zcmd,"REFRESH CANCEL") = 0 then do
    "TBTop" tblname
    mult_space = 0
    do forever
      "TBSkip" tblname
      if rc > 0 then leave
      if scnt + ecnt = 0 then
      if left(zdlvol,6) <> "MIGRAT" then
      action = "D"
      if ecnt > 0 then do
        if action = null then do
          if left(zdlvol,6) <> "MIGRAT" then
          action = "D"
          else action = null
        end
      end
      if left(action,1) = "S" then action = "D"
      if action = "D" then do
        call listdsi "'"cmdsn"'"
        select
          when zdldsorg = "HFS" then do
            Address ISPExec "DSInfo Dataset('"cmdsn"')"
            mult_space = mult_space + zdstota
          end
          when zdldsorg = "VS" then do
            call find_vsam_space "'"cmdsn"'"
            if "'"cmdsn"'" <> vsam_dsn then do
              cmdsn = substr(vsam_dsn,2,length(vsam_dsn)-2)
            end
            if datatype(space_pri) /= 'NUM' then space_pri = 500
            mult_space = mult_space + space_pri
          end
          when left(sysunits,1) = "B" then do
            zdlsize = ((56000%sysblksize)%15) + 1
            mult_space = mult_space + zdlsize
          end
          when left(sysunits,1) = "C" then
          mult_space = mult_space + (sysalloc*15)
          when left(sysunits,1) = "T" then
          mult_space = mult_space + sysalloc
          otherwise nop
        end
        spx = "TRK"
        cd_hit = 0
        do cd = 1 to selected.0
          if word(selected.cd,1) = cmdsn then do
            cd_hit = 1
            scnt     = scnt - 1
          end
        end
        if cd_hit = 0 then do
          cnt = selected.0 + 1
          selected.cnt = cmdsn
          selected.0 = cnt
        end
      end
      if left(action,1) = "E" then do
        e = excluded.0 + 1
        excluded.e = cmdsn
        excluded.0 = e
      end
    end
  end
  "TBEnd" tblname
  if zcmd = "CANCEL" then do
    zcmd = null
    cancel = 1
    zedsmsg = null
    zedlmsg = "Process Cancelled."
    "Setmsg msg(isrz001)"
  end
  return

  /* ------------------------------------------------------------- *
  * Find_Vsam_Space routine                                       *
  * ------------------------------------------------------------- */
Find_Vsam_Space:
  arg vsam_dsn
  space_pri = 0    /* moved here in case vsam check early */
  if multiple = "on" then do
    if right(vsam_dsn,6) = ".DATA'" then return
    if right(vsam_dsn,7) = ".INDEX'" then return
    /* fixed to reflect index and data for ddir */
    if right(vsam_dsn,3) = ".D'" then return
    if right(vsam_dsn,3) = ".I'" then return
  end

  Address TSO
  do until ve = 1
    drop vsam.
    call outtrap "vsam."
    "LISTCAT ENT("vsam_dsn") ALL"
    call outtrap "off"
    cluster = null
    if pos("CLUSTER --",vsam.1) > 0 then ve = 1
    else do i = 1 to vsam.0
      if pos("CLUSTER--",vsam.i) > 0 then
      parse value vsam.i with "CLUSTER--" cluster
      if cluster <> null then do
        vsam_dsn = "'"strip(cluster)"'"
      end
      if cluster <> null then leave
    end
  end

  do i = 1 to vsam.0
    If pos("TRACKS---",vsam.i) > 0 then do
      vsam.i = translate(vsam.i," ","-")
      space_pri = word(vsam.i,8) + space_pri
    end
  end

  balloc     = space_pri
  sysalloc   = space_pri
  sysseconds = space_pri
  space      = "TRK"
  Address ISPExec
  return

Get_GDG:
  /* Rexx - find out absolute dataset name from relative GDG number
  code from Ole Knudsen
  - IBM Global Services - MVS Application Development Support
  */
  "control errors return"
  "lminit dataset("ldsname") dataid(dataid)"
  if rc=0 then do
    ddname = null; sysdsname = null
    "lmquery dataid("dataid") ddname(ddname)"
    x = listdsi(ddname "FILE")
    realdsn=space(sysdsname)
    "lmfree dataid("dataid")"
    dataid = null
    ldsnamex = "'"realdsn"'"
  end
  gdg = "on"
  members = null
  return

Set_Unl_Load:
  if whlq <> null then rhlq = whlq
  d = date(u)
  date = substr(d,7,2)substr(d,1,2)substr(d,4,2)
  s = time("L")  /* get the current time hh:mm:ss.th */
  t = substr(s,1,2)substr(s,4,2)substr(s,7,2)substr(s,10,1)
  /* -------------------------------------------------- *
  * Define the working dataset names that will be used *
  * in this application.                               *
  * -------------------------------------------------- */
  unload_dsn  = hlq"."mlq".UNLOAD.D"date".T"t
  unload_dst  = mlq".UNLOAD.D"date".T"t
  reload_dsn  = rhlq"."mlq".RELOAD.D"date".T"t
  reload_dsnp = mlq".RELOAD.D"date".T"t
  loadjcl_dsn = mlq".LOAD.D"date".T"t
  ftprpt      = mlq".FTPRPT.D"date".T"t
  ftprpt_dsn  = hlq"."ftprpt
  ftpjcl      = mlq".FTPJCL.D"date".T"t
  return

Fix_Send_DSN:
  Select
    When left(from_dsn,1) = "'" then nop
    When length(sysvar('syspref')) = 0 then
    send_dsn = "'"from_dsn"'"
    When length(sysvar('syspref')) > 0 then
    send_dsn = "'"hlq"."from_dsn"'"
    Otherwise nop
  end
  return

  /* ------------------------------------------------------------- *
  * Fix_FTP is a routine to change the thost to the multi host    *
  * when multiple remote hostnames are used                       *
  * ------------------------------------------------------------- */
Fix_FTP:
  /* ------------------------------------------------------------- *
  * 1. Change the remote jobcard for remote host                  *
  * 2. Clean up any submit datasets if submit bypassed            *
  * 3. Change remote hostname in jcl to new remote hostname       *
  * 4. Change the work dsnames to avoid duplicates                *
  * ------------------------------------------------------------- */
  targhost = thost
  targport = thport
  if tls = 'Yes'
  then tlso = '-a tls'
  else tlso = null
  targtls  = tls
  call get_jobid
  call setup_local_jobcard
  call setup_remote_jobcard
  call clean_up_submit
  if od = null then
  od = "D"date
  else od = oda
  dc  = dc + 1
  oda = "D"substr(date,2,5)""dc
  do t = 1 to ftp.0
    if t = netrc_dd then iterate
    if pos('PGM=FTP',ftp.t) > 0 then do
      tl = length(phost)
      pos = pos(phost,ftp.t)
      nl = left(ftp.t,pos-1)
      nr = substr(ftp.t,pos+tl,71)
      ftpparm = strip(tlso thost thport) "(EXIT"
      ftp.t =  "//FTPSTEP  EXEC PGM=FTP,PARM='"ftpparm"'"
    end
    if pos(od".",ftp.t) > 0 then do
      tl = length(od)
      pos = pos(od,ftp.t)
      nl = left(ftp.t,pos-1)
      nr = substr(ftp.t,pos+tl,71)
      ftp.t = nl""oda""nr
    end
    /* test for 2nd occurance of Ddate on FTP statement */
    if pos(od".",ftp.t) > 0 then do
      if t = netrc_dd then iterate
      tl = length(od)
      pos = pos(od".",ftp.t)
      nl = left(ftp.t,pos-1)
      nr = substr(ftp.t,pos+tl,71)
      ftp.t = nl""oda""nr
    end
  end
  /* -------------------------- *
  * fix temp/working dsnames   *
  * to eliminate duplicates    *
  * -------------------------- */
  do t = 1 to load.0
    if pos(od,load.t) > 0 then do
      tl = length(od)
      pos = pos(od,load.t)
      nl = left(load.t,pos-1)
      nr = substr(load.t,pos+tl,71)
      load.t = nl""oda""nr
    end
  end
  if pos(od,loadjcl_dsn) > 0 then do
    tl = length(od)
    pos = pos(od,loadjcl_dsn)
    nl = left(loadjcl_dsn,pos-1)
    nr = substr(loadjcl_dsn,pos+tl,44)
    loadjcl_dsn = strip(nl""oda""nr)
  end
  if pos(od,ftprpt_dsn) > 0 then do
    tl = length(od)
    pos = pos(od,ftprpt_dsn)
    nl = left(loadjcl_dsn,pos-1)
    nr = substr(ftprpt_dsn,pos+tl,44)
    ftprpt_dsn = strip(nl""oda""nr)
  end
  /* -------------------------- *
  * Write out the new jcl into *
  * temp d/s.                  *
  * -------------------------- */
  if rwlj = 0 then do
    rwlj = 1
  end
  call do_local_jcl
  if unl = "Yes" then do
    rwrj = 1
    call do_remote_jcl
  end
  Return

  /* ------------------------------------------------------------- *
  * Now process the foreground execution or background job        *
  * submissions for the file transfer                             *
  * ------------------------------------------------------------- */
Do_FTP:
  call save_remote_jobcard
  submit_flag = null
  tt = time('n')
  tt = left(tt,2)substr(tt,4,2)
  jsuf = ".FTPBJCL.D"date('j')".T"tt".PDS'"
  if sysvar('syspref') = null
  then pdsdsn = "'"sysvar('sysuid')''jsuf
  else pdsdsn = "'"sysvar('syspref')''jsuf
  do forever
    if unl = "No" then
    "Display Panel(ftpbgs)"
    else
    "Display Panel(ftpbgsu)"
    if rc > 4 then do
      if dataid <> null then do
        "Lmfree  Dataid("dataid")"
        dataid = null
        call msg("off")
        Address TSO "Free F("ddn")"
        if netrc = 1 then do
          if usernrc = null then
          Address TSO "Delete '"netrc_dsn"'"
          else Address TSO 'free f(netrc)'
        end
        call clean_up_submit
      end
      zedsmsg = 'Canceled.'
      zedlmsg = 'FTP process canceled.'
      "Setmsg Msg(isrz001)"
      return
    end
    rwrj = 0
    if lj3   = null then lj3 = "//*  "
    if lj4   = null then lj4 = "//*  "
    ftp.1 = lj1
    ftp.2 = lj2
    ftp.3 = lj3
    ftp.4 = lj4
    if unl = "Yes" then do
      if load.1 <> rj1 then rwrj = 1
      if load.2 <> rj2 then rwrj = 1
      if load.3 <> rj3 then rwrj = 1
      if load.4 <> rj4 then rwrj = 1
      load.1 = rj1
      load.2 = rj2
      load.3 = rj3
      load.4 = rj4
      call do_remote_jcl
    end
    call do_local_jcl
    "Vput (lj1 lj2 lj3 lj4) Profile"
    call save_remote_jobcard
    Select
      When opt = "R" then do
        if usernrc = null then do
          zedsmsg = null
          zedlmsg = 'To use this option requires a NETRC dataset.',
            'Put a ? in the Hostname field and then use the NETRC command',
            'to create your personal NETRC dataset. It will be read/write' ,
            'protected to you only.'
          'setmsg msg(isrz001)'
        end
        else do
          Address tso
          if sysdsn(pdsdsn) = 'OK' then do
            call outtrap 'x.'
            'delete' pdsdsn
            call outtrap 'off'
            drop x.
          end
          'Alloc ds('pdsdsn') new spa(1,1) recfm(f b) lrecl(80)' ,
            'blksize(27920) dsorg(po) dir(1) dsntype(library,2)'
          'Free ds('pdsdsn')'

          jcldsn = hlq"."loadjcl_dsn
          rjcl = left(pdsdsn,length(pdsdsn)-1)
          ljcl = rjcl"(local)'"
          rjcl = rjcl"(REMOTE)'"

          'Execio * diskr' ddn '(finis stem ljcl.'
          do jcli = 1 to ljcl.0
            if pos('//DELLOAD',ljcl.jcli) > 0 then do
              ljcl.jcli = '//*DELLOAD DD  Commented out'
              jcli = jcli + 1
              ljcl.jcli = '//*  Commented out'
              jcli = jcli + 1
            end
            if pos(jcldsn,ljcl.jcli) = 0 then iterate
            p = pos(jcldsn,ljcl.jcli)
            pl = length(jcldsn)
            ljcl.jcli = left(ljcl.jcli,p-1) ,
              || substr(rjcl,2,length(rjcl)-2) || substr(ljcl.jcli,p+pl)
          end

          tddn = 'ftp'time('s')
          'alloc f('tddn') ds('ljcl') shr'
          'execio * diskw' tddn '(finis stem ljcl.'
          'free f('tddn')'
          "alloc f("tddn") shr ds('"jcldsn"')"
          'execio * diskr 'tddn' (finis stem rjcl.'
          'free f('tddn')'
          'alloc f('tddn') ds('rjcl') shr'
          'execio * diskw' tddn '(finis stem rjcl.'
          'free f('tddn')'
          address ispexec
          "LMINIT DATAID(pdsegend) DATASET("pdsdsn") Enq(SHR)"
          'LMMStats Dataid('pdsegend') Member(remote)'
          'LMMStats Dataid('pdsegend') Member(local)'
          'edit dataid('pdsegend')'
          'LMFree  Dataid('pdsegend')'
          pdsegend = null
        end
      end
      When opt = "S" then do
        submit_flag = 1
        Address TSO
        "Alloc f(I"ddn") Sysout(A) Writer(INTRDR)",
          "Recfm(F B)"
        "Execio * diskr "ddn" (Finis Stem in."
        if netrc = 0 then do
          do p = 1 to in.0
            if wordpos(ftp_password,in.p) > 0 then do
              if password = '*' then
              apass = null
              else apass = password
              if userid <> "anonymous" then
              in.p = userid apass
              else in.p = userid apass
            end
          end
        end
        else do
          call alloc_netrc
          "Free f(netrc)"
        end
        parse value in.1 with "//" jobname "JOB" .
        "Execio * diskw I"ddn" (Finis Stem in."
        drop in.
        "Free f(I"ddn")"

        Address ISPExec
        "Lmfree  Dataid("dataid")"
        dataid = null
        if unl <> "No" then do
          "Addpop"
          if dss = "Yes" then
          "Display Panel(ftpbgsur)"
          else
          "Display Panel(ftpbgsup)"
          "Rempop"
        end
        else do
          zedsmsg = null
          zedlmsg = "Job" jobname ,
            "has been submitted successfully"
          "Setmsg Msg(isrz001)"
        end
        Address TSO "Free F("ddn")"
        return
      end
      when opt = "X" then do
        if unl = "No" then do
          Address TSO
          "Alloc f(Input) new Unit("vio") spa(1,1) tr Recfm(F b)" ,
            "Lrecl(80) Blksize(0) Reuse"
          "Execio * diskr "ddn" (Finis Stem in."
          n = 0
          do i = 1 to in.0
            if left(in.i,1) = "/" then iterate
            if wordpos(ftp_password,in.i) > 0 then
            in.i = userid password
            n = n + 1
            out.n = in.i
          end
          "Execio * diskw input (Finis Stem out."
          "Alloc f(Output) new unit("vio") spa(15,15) tr reuse"

          if netrc = 1 then do
            call alloc_netrc
          end

          Address ISPEXEC
          "Control Display Lock"
          "Display Panel(ftpbexec)"

          if tls = 'Yes'
          then tlso = '-a tls '
          else tlso = ''
          if thport = null then thport = 21
          'Select PGM(FTP) PARM('tlso''thost thport')'

          Address TSO
          "Free f(input)"
          call msg 'off'
          if netrc = 1 then do
            "Free f(netrc)"
            if usernrc = null then
            "Delete '"netrc_dsn"'"
          end
          Address ISPExec
          "Lminit Dataid(outid) DDName(Output)"
          "Browse Dataid("outid")"
          "Lmfree  Dataid("outid")"
          outid = null
          Address TSO "Free F(output)"
          zedsmsg = ""
          zedlmsg = "Foreground FTP Execution Complete."
          "Setmsg Msg(isrz001)"
          Address TSO "Free F("ddn")"
          return
        end
        else do
          zedsmsg = "Error"
          zedlmsg = "X Option not valid with Unloaded Load Library"
          "Setmsg Msg(isrz001)"
        end
      end
      when opt = "E" then do
        "Edit Dataid("dataid") Macro(ftpbem)"
        Address TSO,
          "Execio * diskr "ddn" (Finis Stem ftp."
      end
      when opt = "B" then
      "Browse Dataid("dataid")"
      when opt = "EL" then do
        "Edit   Dataset('"hlq"."loadjcl_dsn"') Macro(ftpbem)"
        Address TSO
        "Alloc f(T"ddn") shr reuse ds('"hlq"."loadjcl_dsn"')"
        "Execio * diskr T"ddn "(finis stem load."
        "Free f(T"ddn")"
        Address ISPExec
      end
      when opt = "BL" then
      "Browse Dataset('"hlq"."loadjcl_dsn"')"
      otherwise nop;
    end
  end
  Return

  /* -------------------------- *
  * Clean up datasets used     *
  * for job submission.        *
  * -------------------------- */
Clean_Up_Submit:
  if submit_flag <> 1 then do
    x = Msg("off")
    Address TSO
    "Delete '"hlq"."loadjcl_dsn"'"  /* eha 08 jul 2008 */
    if alloc_netrc = 1 then do
      if usernrc = null
      then "Delete '"netrc_dsn"'"
      else "Free F(netrc)"
      alloc_netrc = 0
    end
    Address ISPExec
  end
  submit_flag      = null
  loadjcl_dsn_flag = null
  return

  /* ------------------------------------------------------------- *
  * Setup the remote job card to be used for the remote job       *
  * submission.                                                   *
  * Use correct userid for jobname to allow jesgetputto.          *
  * ------------------------------------------------------------- */
Setup_Remote_Jobcard:
  parse value "" with rj1 rj2 rj3 rj4
  "TBOpen ftpjobcd Write Library(ISPPROF)"
  if rc = 8 then call create_table
  'tbquery ftpjobcd keys(tkeys)'
  if pos('TARGPORT',tkeys) = 0 then call update_ftpjobcd_table
  "TBTop ftpjobcd"
  do forever
    "TBSkip ftpjobcd"
    if rc > 0 then leave
    if targhost = thost then leave
  end
  if rj1 = null then do
    rj1 = ftp.1
    rj2 = ftp.2
    rj3 = ftp.3
    rj4 = ftp.4
  end
  if userid = null then
  if usernrc /= null
  then userid = get_nrc_uid()
  if userid = 0 then userid = sysvar('sysuid')
  parse value rj1 with "//" jobname "JOB" rest
  Uuserid = translate(userid)
  if forcejbn = "Y" then do
    jobname = Uuserid""jobsuf
    rj1 = "//"jobname "JOB" strip(rest)
  end
  else do
    if left(jobname,length(Uuserid)) = userid then do
      jobname = Uuserid""jobsuf
      rj1 = "//"jobname "JOB" strip(rest)
    end
    if left(jobname,length(zuser)) = zuser then do
      jobname = Uuserid""jobsuf
      rj1 = "//"jobname "JOB" strip(rest)
    end
  end
  load.1 = rj1
  load.2 = rj2
  load.3 = rj3
  load.4 = rj4
  tbput_rc = 0
  if targhost = thost then do
    "TBPut   ftpjobcd"
    tbput_rc = 4
  end
  if tbput_rc = 4 then
  if left(thost,1) <> "*" then
  if pos(thost,"*?") = 0 then do
    targhost = thost
    "TBAdd   ftpjobcd"
  end
  "TBSort  ftpjobcd Fields(targhost)"
  "TBSave  ftpjobcd Library(ISPPROF)"
  "TBClose ftpjobcd Library(ISPPROF)"
  return

  /* -------------------------- *
  * Construct the jobcard to   *
  * be used locally.           *
  * -------------------------- */
Setup_Local_jobcard:
  parse value lj1 with "//" jobname "JOB" rest
  if left(jobname,length(zuser)) = zuser then do
    jobname = zuser""jobsuf
    lj1 = "//"jobname "JOB" strip(rest)
  end
  ftp.1 = lj1
  ftp.2 = lj2
  ftp.3 = lj3
  ftp.4 = lj4
  return

  /* -------------------------- *
  * Save the remote jobcard    *
  * that was used.             *
  * -------------------------- */
Save_Remote_Jobcard:
  "TBOpen ftpjobcd Write Library(ISPPROF)"
  if rc = 8 then call create_table
  do forever
    "TBSkip ftpjobcd"
    if rc > 0 then leave
    if targhost = thost then leave
  end
  rj1 = load.1
  rj2 = load.2
  rj3 = load.3
  rj4 = load.4
  targhost = thost
  if rc > 0 then
  "TBAdd   ftpjobcd"
  else
  "TBPut   ftpjobcd"
  "TBSort  ftpjobcd Fields(targhost)"
  "TBSave  ftpjobcd Library(ISPPROF)"
  "TBClose ftpjobcd Library(ISPPROF)"
  return

  /* ------------------------------------------------------------- *
  * Get_Hostname routine.                                         *
  * Used when the user enters a ? on the remote Hostname field    *
  * to display the current set of used hostnames from which to    *
  * select.                                                       *
  * Optionally:                                                   *
  *     D - delete entry from the table.                          *
  *     C - clone entry (create new host name)                    *
  *     U - update entry (change JCL)                             *
  *     \ - unselect an entry                                     *
  * ------------------------------------------------------------- */
Get_Hostname:
  call build_thost_table
  mult_sels = 0
  mhst = null
  crp = 1
  rowcrp = 0
  last_find = 0
  do forever
    hsel = null
    if words(mhst) > 0 then
    if zedsmsg = null then do
      zedsmsg = null
      zedlmsg = "Selections made  - enter PF3(END) or ENTER",
        "when ready to proceed."
      "Setmsg Msg(isrz001)"
    end
    zcmd = null
    "TBTop  thosttbl"
    "TBSkip thosttbl Number("crp")"
    if mult_sels = 0 then do
      if rowcrp = 0 then
      "TBDispl thosttbl Panel(ftpbshst)"
      else
      "TBDispl thosttbl Panel(ftpbshst)",
        "Csrrow("rowcrp") AutoSel(No)"
    end
    else
    "TBDispl thosttbl"
    xrc = rc
    mult_sels = ztdsels
    if ztdsels = 0
    then if words(mhst) > 0 then xrc = 8
    if xrc > 7 then do
      call save_thost_table
      if words(mhst) > 0 then return
      signal start
    end
    Select
      when abbrev("SORT",word(zcmd,1),1) = 1 then do
        if left(word(zcmd,2),1) = 'A'
        then "TBSort thosttbl Fields(targhost,C,A)"
        else "TBSort thosttbl Fields(targhost,C,D)"
        xrc = 0
        targhost = "?"
      end
      when abbrev("FIND",word(zcmd,1),1) = 1 then do
        call do_find "thosttbl"
        targhost = "?"
        xrc = 0
      end
      when zcmd = "NETRC" then do
        if usernrc /= null then do
          if sysvar('syspref') = null
          then usernrc = 'NETRC'
          else usernrc = "'"sysvar('sysuid')".NETRC'"
        end
        'vput (usernrc) profile'
        x = ftpbnrc(usernrc)
      end
      when abbrev("RFIND",word(zcmd,1),2) = 1 then do
        zcmd = "RFIND" argument
        call do_find "thosttbl"
        targhost = "?"
        xrc = 0
      end
      Otherwise nop
    end
    if ztdsels > 0 then do
      "TBGet thosttbl"
      Select
        when hsel = "D" then do
          "TBDelete thosttbl"
          xrc = 0
        end
        when hsel = "C" then do
          currhost = targhost
          targhost = strip(targhost)
          "control display save"
          "Display Panel(FTPBCHST)"
          if rc = 0 then do
            tsel = "Clone"
            if targhost /= null then
            "TBAdd thosttbl order"
          end
          "control display restore"
        end
        when hsel = "U" then do
          "control display save"
          "Display Panel(FTPBUHST)"
          if rc = 0 then do
            tsel = "Update"
            "TBMod thosttbl"
          end
          "control display restore"
        end
        when hsel = "\" then do
          do iht = 1 to words(mhst)
            mhstw = word(mhst,iht)
            if pos(targhost,mhst) = 0 then iterate
            pw = iht
            leave
          end
          if pw > 0 then do
            mhst = delword(mhst,pw,1)
            tsel = null
            "TBMod thosttbl"
            targhost = "?"
          end
          else targhost = '?'
          xrc = 0
        end
        when hsel = null then targhost = null
        otherwise do
          if mvs = 'Sync' then do
            if words(mhst) = 1
            then do
              zedsmsg = 'Error'
              zedlmsg = 'Only 1 Host may be selected for a Sync Operation'
              'setmsg msg(isrz001)'
            end
          end
          if zedsmsg = null then do
            mhst = mhst targhost":"targport":"targtls
            tsel = "Select"
            "TBMod thosttbl"
          end
          if mult_sels > 0 then
          targhost = "?"
        end
      end
      if pos(hsel,"CDU") > 0 then targhost = "?"
      thost  = targhost
      thport = targport
      tls    = targtls
      if thost <> "?" then leave
    end
  end
  call save_thost_table
  return

  /* --------------------- *
  | Get Userid from NETRC |
  * --------------------- */
Get_NRC_Uid:
  Address TSO
  nrcdd = 'NRC'random(9999)
  'Alloc f('nrcdd') shr reuse ds('usernrc')'
  'Execio * diskr' nrcdd '(finis stem nrc.'
  'Free f('nrcdd')'
  Address ISPExec
  do ni = 1 to nrc.0
    if translate(word(nrc.ni,1)) = 'MACHINE' then do
      nrcip = word(nrc.ni,2)
      nrcuid = word(nrc.ni,4)
    end
    if nrcip = thost then do
      drop nrc.
      return nrcuid
    end
  end
  drop nrc.
  return 0

Create_Table:
  "TBCreate ftpjobcd keys(targhost targport)",
    "Names(rj1  rj2  rj3 rj4 targtls thdesc)",
    "Replace  Library(ISPPROF)"
  return

Save_Thost_Table:
  call Create_Table
  "TBTop thosttbl"
  "TBQuery thosttbl rownum(rows)"
  do rw = 1 to rows
    "TBSkip thosttbl"
    "TBGet  thosttbl"
    targhost = strip(targhost)
    "TBAdd ftpjobcd"
  end
  "TBSave  ftpjobcd Library(ISPPROF)"
  "TBClose ftpjobcd Library(ISPPROF)"
  "TBEnd   thosttbl"
  if words(mhst) = 1 then parse value mhst with thost":" .
  return

Build_Thost_Table:
  "TBOpen ftpjobcd Write Library(ISPPROF)"
  if rc = 8 then do
    call Create_Table
    call new_thost_table_entry
  end
  'tbquery ftpjobcd rownum(rows)'
  if rows = 0 then call new_thost_table_entry
  "TBTop ftpjobcd"
  "TBCreate thosttbl keys(targhost targport)",
    "Names(tsel rj1  rj2  rj3 rj4 targtls thdesc)"
  tsel = null
  "TBQuery ftpjobcd rownum(rows)"
  do rw = 1 to rows
    "TBSkip ftpjobcd"
    "TBGet  ftpjobcd"
    targhost = strip(targhost)
    if targhost /= null then
    "TBAdd  thosttbl"
  end
  "TBSort thosttbl fields(targhost)"
  "TBTop thosttbl"
  "TBClose ftpjobcd Library(ISPPROF)"
  return

New_Thost_Table_Entry:
  targhost = "change-me"
  call set_initial_jobcard
  rj1 = lj1
  rj2 = lj2
  rj3 = lj3
  rj4 = lj4
  "TBadd ftpjobcd"
  return

  /* -------------------------- *
  * setup initial jobcard mask *
  * -------------------------- */
set_initial_jobcard:
  lj1 = jc1
  lj2 = jc2
  lj3 = jc3
  lj4 = jc4
  if lj4 = null then lj4 = '//*'
  if lj3 = null then lj3 = '//*'
  if lj2 = null then lj2 = '//*'
  "Vput (lj1 lj2 lj3 lj4) Profile"
  return

  /* ---------------------------------------------------- *
  * Setup the Netrc DSN                                  *
  * ---------------------------------------------------- */
Set_Netrc:
  if usernrc /= null then return
  if netrc <> 1 then return
  d = date('u')
  date = substr(d,7,2)substr(d,1,2)substr(d,4,2)
  s = time("L")  /* get the current time hh:mm:ss.th */
  t = substr(s,1,2)substr(s,4,2)substr(s,7,2)substr(s,10,1)
  netrc_dsn   = netrc_hlq"."mlq".NETRC.D"date".T"t
  Address ISPExec
  alloc_netrc = 1
  xx = netrc_dd
  ftp.xx = "//          DSN="netrc_dsn
  return

  /* --------------------- *
  * Allocate the Netrc DD *
  * --------------------- */
Alloc_Netrc:
  if usernrc = null then do
    netrc.1 = "MACHINE" thost "LOGIN" id "PASSWORD" pw
    Address TSO
    "Alloc f(netrc) new Unit("dasd") spa(1,1) tr" ,
      "Recfm(V B)" ,
      "Lrecl(255) Blksize(0) Reuse ds('"netrc_dsn"')"
    "Execio * diskw netrc (Finis Stem netrc."
    drop netrc.
    call set_netsec
  end
  else
  Address TSO "Alloc f(netrc) shr reuse ds('"usernrcl"')"
  return

  /* ---------------------------------------------------------- *
  * Set_Netsec Routine            *netsec* local customization *
  *                                                            *
  * This routine will set the security access to the NETRC     *
  * data set so only the user can see it.                      *
  *                                                            *
  * It is provided with RACF, ACF2, and Top Secret (TSS).      *
  * ---------------------------------------------------------- */
Set_Netsec:
  if usernrc /= null then return
  if netsec = 0 then return
  Select
    When netsec = "RACF" then do
      "Addsd  '"netrc_dsn"' UACC(none)"
      "Permit '"netrc_dsn"' Access(alter) ID("sysvar('sysuid')")"
    end
    When netsec = "ACF2" then do
      "ACFNRULE KEY("sysvar('sysuid')" ADD( NETRC UID(*))"
    end
    When netsec = "TSS" then do
      "tss permit(all) dsname("netrc_dsn") acc(none)"
      "tss permit("sysvar('sysuid')" dsname("netrc_dsn") access(all)"
    end
    Otherwise nop
  end
  Return

FTP_Site_Info:
  /* -------------------------- *
  * Set space allocation       *
  * and DCB.                   *
  * -------------------------- */
  if sdb = 0 then blk = 0
  else blk = sysblksize
  if sp = "Blocks" then blk = sysblksize
  pri = sysalloc
  sec = sysseconds
  if sysadirblk = 'NO_LIM'
  then direct = 'P'
  else direct = sysadirblk
  targdsn = targ_dsn
  "Display Panel(FTPBSITE)"
  if direct = 0 then direct = null
  if length(direct) > 0 then do
    if direct /= 'PDSE'
    then sysadirblk = direct
    else sysadirblk = null
  end
  sysunits = sp
  sysalloc   = pri
  sysseconds = sec
  if sp <> null then site_sp = sp
  if left(direct,1) = 'P'
  then sp = sp 'pdstype=pdse'
  else if direct /= null then sp = sp 'direct='direct
  select
    when sp = "Blocks" then space = "BLK"
    when sp = "TR" then space = "TRK"
    when sp = "CYL" then space = "CYL"
    otherwise space = sp
  end
  parse value sysalloc*1.5 with sysalloc'.'.
  balloc = "("sysalloc","sysseconds")"
  palloc = "("sysalloc","sysseconds")"
  if rel = "Yes" then rlse = ",RLSE"
  else rlse = ""
  return

  /* -------------------------------------------- *
  * Get Data Set Name for supplied DD and Member *
  * -------------------------------------------- */
Get_DSN: Procedure Expose return_dsn null
  arg dd cmd
  return_dsn = null

  call outtrap 'trap.'
  "lista sta"
  call outtrap 'off'

  hit = 0
  cnt = 0
  tdd = null

  do i = 1 to trap.0
    if tdd = dd then hit = 1
    if hit = 1 then
    if tdd <> dd then leave
    if left(trap.i,2) = "--" then iterate
    if left(trap.i,1) <> " " then do
      dsn = word(trap.i,1)
    end
    else do
      if left(trap.i,3) = "   " then do
        if tdd <> dd then iterate
        cnt = cnt + 1
        dsn.cnt = tdd dsn
      end
      else do
        tdd = word(trap.i,1)
        if tdd <> dd then iterate
        cnt = cnt + 1
        dsn.cnt = tdd dsn
      end
    end
  end

  do i = 1 to cnt
    if "OK" = sysdsn("'"word(dsn.i,2)"("cmd")'") then do
      return_dsn = word(dsn.i,2)
      leave
    end
  end
  return

  /* ----------------------------------------------------- *
  * Find sub-routine                                      *
  * ----------------------------------------------------- */
Do_Find:
  arg table_name
  parse value zcmd with o1 argument
  upper argument
  argument = strip(argument)
  zsel = ''
  hit  = 1
  hcc  = 0
  crp  = ztdtop
  find_loop = ''
  search    = ''
  rowid     = crp
  if o1    <> "RFIND" then do
    last_find = crp - 1
    o1        = "RFIND"
  end
  if o1     = "RFIND" then do
    last_find = last_find + 1
    "TBTOP " table_name
    "TBSKIP" table_name "Position(ROWID) Number("Last_find")"
  end
  else do
    "TBSKIP" table_name "Position(rowid)"
  end
  if rc = 8 then do
    "TBTop" table_name
    "TBSKIP" table_name "Position(ROWID)"
    s_smsg = "Wrapped"
  end
  else s_smsg = "Found"

  /* perform search */

  do forever
    if left(table_name,4) = "FTPB" then
    search = translate(cmdsn)
    if left(table_name,5) = "THOST" then
    search = translate(targhost) translate(thdesc)
    if pos(argument,search) > 0 then do
      crp = rowid + 0
      rowcrp = crp
      last_find = crp
      zedsmsg = s_smsg  /* "Found" */
      zedlmsg = argument "found during search in row:" crp
      "Setmsg Msg(isrz001)"
      leave
    end
    "TBSKIP" table_name "POSITION(Rowid)"
    if rc = 8 then do
      "TBTOP" table_name
      s_smsg = "Wrapped"
      if find_loop = "on" then do
        zedsmsg = "Not Found"
        zedlmsg = argument "Not found during search"
        rowid = crp
        "Setmsg Msg(isrz001)"
        leave
      end
      else find_loop = "on"
    end
    zsel = ''
  end
  return

  /* ------------------------------ *
  | 2 line popup for notifications |
  * ------------------------------ */
Do_Pop2:
  'Control Display Lock'
  'addpop'
  'display panel(ftpbpop2)'
  'rempop'
  parse value '' with m1 m2
  return

  /* ------------------------------ *
  | 4 line popup for notifications |
  * ------------------------------ */
Do_Pop4:
  'Control Display Lock'
  'addpop'
  'display panel(ftpbpop4)'
  'rempop'
  parse value '' with m1 m2 m3 m4
  return

  /* ----------------------------------- *
  | Check if the remote dataset exists? |
  * ----------------------------------- */
Check_Remote:
  arg test_dsn
  drop ftpx.
  fc = 0
  if translate(psv) = 'YES' then do
    fc = fc + 1
    ftpx.fc = 'locsite fwfriendly epsv4'
  end
  if strip(other) /= null then do
    fc = fc + 1
    ftpx.fc = other
  end
  fc = fc + 1
  ftpx.fc = 'dir' test_dsn
  fc = fc + 1
  ftpx.fc = 'quit'
  ftpx.0 = fc
  m1 = 'Checking the Remote System for'
  m2 = 'Dataset:' test_dsn
  call do_pop2
  call do_ftpx
  Address ISPExec
  do i = 1 to out.0
    if pos('is not found',out.i) > 0 then return 1
    if pos('No data sets found.',out.i) > 0 then return 1
    if pos('530 You must first login with USER and PASS.',out.i) > 0
    then return 2
    if pos('Connection to server interrupted or timed out.',out.i) > 0
    then return 3
  end
  return 0

  /* ------------------------------ *
  | Process the FTP command online |
  * ------------------------------ */
Do_FTPx:
  Address TSO
  if usernrc /= null
  then  'Alloc f(netrc) ds('usernrc') shr reuse'
  else do
    'alloc f(netrc) recfm(v b) lrecl(255) blksize(0) spa(1,1) tr reuse'
    netrc.1 = "MACHINE" thost "LOGIN" userid "PASSWORD" password
    netrc.0 = 1
    'execio * diskw netrc (finis stem netrc.'
  end
  'Alloc f(input) spa(1,1) tr recfm(f b) lrecl(80) blksize(32720) reuse'
  'Alloc f(output) spa(15,15) tr reuse'
  'Execio * diskw input (finis stem ftpx.'
  call outtrap 'pds.'
  ftphost = thost thport
  Address Linkmvs 'ftp ftphost'
  call outtrap 'off'
  'execio * diskr output (finis stem out.'
  'free f(input output netrc)'
  return

  /* ---------------------------------------------------------- *
  | Perform a Sync between two partitioned datasets, one local |
  | and the other remote.                                      |
  * ---------------------------------------------------------- */
Do_Sync:
  lpds = test_ldsname
  rpds = rdsname
  if rpds = null then rpds = lpds
  rdsnamex = rpds
  x = check_remote_dataset(rpds)
  if x = 1 then do
    zedsmsg = 'Error.'
    zedlmsg = rpds 'was not found - it may need to be fully qualified' ,
              'with quotes.'
    'setmsg msg(isrz001)'
    return
  end
  if x = 4 then do
    zedsmsg = 'Cancelled.'
    zedlmsg = 'You have cancelled the FTP request.'
    'setmsg msg(isrz001)'
    return
  end
  if x = 2 then do
    zedsmsg = 'Error.'
    zedlmsg = 'You have not provided a valid userid/password to' ,
      'connect to the remote system.'
    'setmsg msg(isrz001)'
    return
  end
  if x = 3 then do
    zedsmsg = 'Error.'
    zedlmsg = 'You have not provided a valid remote hostname or' ,
      'I.P. address.'
    'setmsg msg(isrz001)'
    return
  end
  if new = 'Yes' then
  call ftp_site_info
  m1 = 'Getting a list of all members from both'
  m2 = 'the local and remote systems.'
  call do_pop2
  call get_member_lists
  drop pds. out.
  call proc_member_list
  return

  /* ---------------------------------------------------------- *
  | Perform a GET operation by providing a list of datasets on |
  | the remote site allowing the user to select one, or more,  |
  | datasets to retrieve.                                      |
  * ---------------------------------------------------------- */
Do_Get:
  gdsname = strip(rdsname)
  if left(gdsname,1) = "'" then
  gdsname = strip(gdsname,'B',"'")
  if right(gdsname,3) = '.**' then
  gdsname = "'"left(gdsname,length(gdsname)-3)"'"
  m1 = 'Getting a list of all members from both'
  m2 = 'the local and remote systems.'
  call do_pop2
  call get_dataset_list
  return

  /* ------------------------- *
  | Setup the JCL for the FTP |
  * ------------------------- */
Setup_JCL:
  /* ---------------------------------------------------------- *
  * Get a unique id character for the job card along with the  *
  * userid and account number information.                     *
  * ---------------------------------------------------------- */
  call get_jobid

  "Vget (lj1 lj2 lj3 lj4) Profile"

  /* -------------------------- *
  * Setup Default Job Card     *
  * -------------------------- */
  if lj1 = null then call set_initial_jobcard

  /* -------------------------- *
  * Add comments to job        *
  * -------------------------- */
  call setup_local_jobcard
  ftp.5  = "//*-----------------------------------------------*"
  ftp.6  = "//*    FTP Batch JCL Generated by FTPB Dialog     *"
  datex = left(date(),11)
  timex = left(time(),8)
  ftp.7 =  "//*    Release" ftpbver "on" datex "at" timex "  *"
  ftp.8  = "//*-----------------------------------------------*"
  ftp.0  = 8

  /* -------------------------- *
  * setup reload job card      *
  * -------------------------- */
  if rj1 = null then do
    load.1 = ftp.1
    load.2 = ftp.2
    load.3 = ftp.3
    load.4 = ftp.4
  end
  else call setup_remote_jobcard
  load.5 = "//*-----------------------------------------------*"
  load.6 = "//*    FTP ReLoad JCL Generated by FTPB Dialog    *"
  load.7 = "//*    Release" ftpbver "on" datex "at" timex "  *"
  load.8 = "//*-----------------------------------------------*"
  load.0 = 8

  lj1 = ftp.1
  lj2 = ftp.2
  lj3 = ftp.3
  lj4 = ftp.4

  rj1 = load.1
  rj2 = load.2
  rj3 = load.3
  rj4 = load.4
  return

  /* ---------------------------------- *
  | Check if the remote dataset exists |
  * ---------------------------------- */
Check_Remote_Dataset:
  arg test_dsn
  new = null
  dln = null
  x = check_remote(test_dsn)
  if x = 1 then new = 'Yes'
  else new = 'No'
  if ftpgp = 'S'
     then if x = 1
     then return 1
  if x = 2 then return 2
  if x = 3 then return 3
  alloc = x
  if new = 'Yes' then
  "Display Panel(ftpbppds)"
  if rc > 4 then return 4
  return 0

  /* --------------------------------------------------------- *
  | Get a list of all datasets on the remote site and allow   |
  | the user to select those datasets to pull (ftp get) back. |
  * --------------------------------------------------------- */
Get_Dataset_list:
  test_gdsname = translate(gdsname,' ','.')
  if words(test_gdsname) > 1 then do
    check_gdsname = word(test_gdsname,words(test_gdsname))
    test_gdsname = subword(test_gdsname,1,words(test_gdsname)-1)
  end
  else check_gdsname = null
  test_gdsname = translate(test_gdsname,'.',' ')
  check_glen = length(check_gdsname)

  fc = 0
  if translate(psv) = 'YES' then do
    fc = fc + 1
    ftpx.fc = 'locsite fwfriendly epsv4'
  end
  if strip(other) /= null then do
    fc = fc + 1
    ftpx.fc = other
  end
  fc = fc + 1
  ftpx.fc = 'cd' "'"test_gdsname"'"
  fc = fc + 1
  ftpx.fc = 'dir'
  fc = fc + 1
  ftpx.fc = 'quit'
  ftpx.0 = fc

  call do_ftpx

  ghit = 0
  max_used = 0
  gdsname = strip(test_gdsname,,"'")
  gdsnlen = length(test_gdsname) + 1
  gtab = 'ftpb'random(9999)
  'tbcreate' gtab 'names(gdsn gact gvol gused grecfm glrecl gblksize gdsorg)' ,
    'nowrite'
  do gdx = 1 to out.0
    if subword(out.gdx,2,2) = 'Volume Unit' then leave
    if pos('530 You must first login with USER and PASS.',out.gdx) > 0
    then do
      zedsmsg = 'Error.'
      zedlmsg = out.gdx
      'Setmsg msg(isrz001)'
      return
    end
    if pos('Connection to server interrupted or timed out.',out.gdx) > 0
    then do
      zedsmsg = 'Error.'
      zedlmsg = out.gdx
      'Setmsg msg(isrz001)'
      return
    end
  end
  gcount = 0
  gact = null
  do gdi = gdx+1 to out.0
    if subword(out.gdi,2,2) = 'List completed' then leave
    parse value out.gdi with xm gvol xu grefd . gused grecfm glrecl gblksize  ,
      gdsorg gdsn
    gdsn = strip(gdsn)
    if gdsn = null then iterate
    if left(gdsn,check_glen) /= check_gdsname then iterate
    gdsn = gdsname'.'strip(gdsn)
    if gused > max_used then max_used = gused
    'tbadd' gtab
    gcount = gcount + 1
  end

  if gcount = 0 then do
    'tbend' gtab
    zedsmsg = 'No Datasets.'
    zedlmsg = 'No Datasets were found with the provided HLQ of' gdsname
    'Setmsg msg(isrz001)'
    return
  end

  'tbsort' gtab  'field(gdsn,ch,a)'
  'tbtop'  gtab
  gtdsels = 0
  get_count = 0
  do forever
    gsel = null
    if gtdsels = 0 then
    'tbdispl' gtab 'panel(ftpbrdsl)'
    else 'tbdispl' gtab
    if rc > 4 then leave
    gtdsels = ztdsels

    if zcmd /= null then
    Select
      When Abbrev("REFRESH",translate(zcmd),3) = 1 then do
        'tbend' gtab
        call get_dataset_list
        return
      end
      When Abbrev("CANCEL",translate(zcmd),3) = 1 then do
        'tbend' gtab
        zedsmsg = 'Canceled.'
        zedlmsg = 'Get process cancelled.'
        'setgmsg msg(isrz001)'
        return
      end
      otherwise nop
    end

    if gsel /= null then do
      Select
        When gsel = 'S' then do
          if wordpos(gdsorg,'PS PO') = 0 then do
            zedsmsg = 'Not Supported.'
            zedlmsg = 'The selected dataset dsorg is not supported.'
            'setmsg msg(isrz001)'
          end
          else do
            gact = 'Select'
            get_count = get_count + 1
          end
        end
        When gsel = 'U' then
        if gact /= null then do
          gact = null
          if get_count > 0 then
          get_count = get_count - 1
        end
        Otherwise nop
      end
      'tbput' gtab
    end
  end

  if get_count > 0 then do
    'vget (mgen) profile'
    if rdsname /= null then newhlq = rdsname
    if datatype(mgen) /= 'NUM' then mgen = 0
    'Display Panel(ftpbrdsp)'
    'vput (mgen) profile'
    call setup_jcl
    call set_ftp
    gftpc = ftp.0
    'tbtop' gtab
    do forever
      'tbskip' gtab
      if rc > 0 then leave
      if gact = null then iterate
      rep = null
      call fix_get_dsn
      gftpc = gftpc + 1
      ftp.gftpc = 'mvsget' "'"gdsn"' +"
      gftpc = gftpc + 1
      ftp.gftpc = "   '"newdsn"' (Realloc"
    end
    gftpc = gftpc + 1
    ftp.gftpc = 'quit'
    gftpc = gftpc + 1
    ftp.gftpc = '/*'
    ftp.0 = gftpc
    rdsnamex = newhlq
    call do_ftp
  end

  'tbend' gtab
  Return

  /* ----------------------------------------------------- *
  | Fix up the local dataset name using the new local hlq |
  | provided.                                             |
  * ----------------------------------------------------- */
Fix_Get_DSN:
  wold = translate(ldsname,' ','.')
  wnew = translate(newhlq,' ','.')
  wold = words(wold)
  wneww = words(wnew)
  gdsnw = translate(gdsn,' ','.')
  newdsn = wnew subword(gdsnw,wneww+1)
  newdsn = translate(strip(newdsn),'.',' ')
  return

  /* -------------------------------------------- *
  | Get the list of all members local and remote |
  * -------------------------------------------- */
Get_Member_Lists:
  mult = 1
  fc = 0
  if translate(psv) = 'YES' then do
    fc = fc + 1
    ftpx.fc = 'locsite fwfriendly epsv4'
  end
  if strip(other) /= null then do
    fc = fc + 1
    ftpx.fc = other
  end
  fc = fc + 1
  ftpx.fc = 'cd' rpds
  fc = fc + 1
  ftpx.fc = 'lcd' lpds
  fc = fc + 1
  ftpx.fc = 'TSO %ftpbpdir' lpds
  if new = 'No' then do
    fc = fc + 1
    ftpx.fc = 'dir'
    fc = fc + 1
    ftpx.fc = 'quit'
    ftpx.0 = fc
  end
  else do
    fc = fc + 1
    ftpx.fc = 'quit'
    ftpx.0 = fc
  end

  call do_ftpx

  drop mem.
  mem. = null

  /* Process remote PDS directory from FTP Log */
  do i = 1 to out.0
    if pos('VV.MM',out.i) > 0 then leave
  end
  if wordpos('VV.MM',out.i) = 3
  then off = 2
  else off = 1
  i = i + 1
  out_ic  = i
  out_off = off

  if alloc = 0 then
  do ip = i to out.0
    if pos('List completed',out.ip) > 0 then leave
    member = word(out.ip,off)
    if sync_member /= null then
    if patmatch(sync_member,member) = 0 then iterate
    chg_time = null
    rsize = null
    chg_date = word(out.ip,off+3)
    if strip(chg_date) /= null then do
      chg_date = left(chg_date,4)''substr(chg_date,6,2)''right(chg_date,2)
      chg_time = word(out.ip,off+4)
      chg_time = left(chg_time,2)''right(chg_time,2)
      rsize    = word(out.ip,off+5)
    end
if member = 'remote CPM2TMPJ' then say member chg_date /* $$ */
    mem.0 = mem.0 member
    if chg_date = null then chg_date = '-NoStats-'
    mem.member = chg_date chg_time rsize
  end

  /* Process the local PDS directory from trap */
  ftp_table = 'FT'random(99999)
  'tbcreate' ftp_table 'names(fmem fstate ldate ltime lsize' ,
    'rdate rtime rsize) nowrite'
  transfer. = null
  transfer_count = 0
  members = null
  do ip = 2 to pds.0
    member = word(pds.ip,1)
    if sync_member /= null then
    if patmatch(sync_member,member) = 0 then iterate
    parse value ''  with ldate ltime rdate rtime lsize rsize
    if wordpos(member,members) = 0 then members = members member
    chg_time = null
    chg_date = word(pds.ip,4)
    if chg_date = null
    then chg_date = '-NoStats-'
    if strip(chg_date) /= null then do
      chg_time = word(pds.ip,5)
      lsize = word(pds.ip,6)
    end
    if chg_date /= '-NoStats-' then
    if strip(chg_date) /= null then do
      if strip(chg_date) /= null then  do
        chg_date = left(chg_date,2)''substr(chg_date,4,2)''right(chg_date,2)
        year = left(chg_date,2)
        /* ------------------------------------------------------------- *
        | Convert the PDS result 2 digit year to a 4 digit year.        |
        | If the year is < 80 then the century is 20 otherwise it is 19 |
        * ------------------------------------------------------------- */
        if year < 80
        then chg_date = '20'chg_date
        else chg_date = '19'chg_date
        parse value chg_time with hh':'mm
        chg_time = right(hh+100,2)''mm
      end
    end
if member = 'local  CPM2TMPJ' then say member chg_date /* $$ */

    if alloc = 0 then do
      fstate = null
      frmem = member chg_date chg_time lsize
      tomem = member mem.member
      if frmem /= tomem then Select
        when word(mem.member,1) < chg_date then fstate = 'PUT'
        when word(mem.member,1) > chg_date then fstate = 'GET'
        when word(mem.member,1) = chg_date
        then select
          when word(mem.member,2) < chg_time then fstate = 'PUT'
          when word(mem.member,2) > chg_time then fstate = 'GET'
          otherwise nop
        end
        otherwise nop
      end
    end
    else do
      fstate = 'PUT'
      mem.member = null
    end

    fmem = member
    ldate = chg_date
    if ldate /= '-NoStats-' then
    if strip(ldate) /= null then
      ldate = left(ldate,4)'.'substr(ldate,5,2)'.'right(ldate,2)
    if chg_time /= null then
    ltime = left(chg_time,2)':'right(chg_time,2)
    rdate = word(mem.member,1)
    if left(rdate,1) /= '-' then
    if strip(rdate) /= null then
      rdate = left(rdate,4)'.'substr(rdate,5,2)'.'right(rdate,2)
    rtime = word(mem.member,2)
    rsize = word(mem.member,3)
    if rtime /= null then
    rtime = left(word(mem.member,2),2)':'right(word(mem.member,2),2)
    if mult = 1 then mult = 'mult('pds.0')'
    else mult = null
    if wordpos(fmem,mem.0) = 0 then fstate = 'PUT'
    if rdate = null then rdate = '-NotFound-'
    if syd = 'Yes' then
    if fstate /= null
    then 'tbadd' ftp_Table mult
    if syd = 'No'
    then 'tbadd' ftp_Table mult
    if wordpos(fmem,transfer.0) = 0 then
    transfer.0 = transfer.0 fmem
    transfer.fmem = fstate
    if fstate /= null then
    transfer_count = transfer_count + 1
  end

  parse value '' with ldate ltime lsize
  do ip = out_ic to out.0
    if pos('List completed',out.ip) > 0 then leave
    fmem = word(out.ip,off)
    if sync_member /= null then
    if patmatch(sync_member,fmem) = 0 then iterate
    if wordpos(fmem,members) > 0 then iterate
    rtime = null
    rdate = word(out.ip,off+3)
    if left(rdate,1) /= '-' then
    if strip(rdate) /= null then do
      rdate = left(rdate,4)'.'substr(rdate,6,2)'.'right(rdate,2)
      rtime = word(out.ip,off+4)
      rsize = word(out.ip,off+5)
      fstate = 'GET'
      transfer_count = transfer_count + 1
      transfer.0 = transfer.0 fmem
      transfer.fmem = fstate
      members = members fmem
      if ldate = null then ldate = '-NotFound-'
      if rdate = null then rdate = '-NotFound-'
      if syd = 'Yes' then
      if fstate /= null
      then 'tbadd' ftp_Table mult
      if syd = 'No'
      then 'tbadd' ftp_Table mult
    end
  end

  do i = 1 to words(mem.0)
    fmem = word(mem.0,i)
    if wordpos(fmem,members) > 0 then iterate
    parse value mem.fmem with rdate rtime rsize
    if left(rdate,1) /= '-' then
       rdate = left(rdate,4)'.'substr(rdate,6,2)'.'right(rdate,2)
    rtime = word(out.ip,off+4)
    rsize = word(out.ip,off+5)
    fstate = 'GET'
    transfer_count = transfer_count + 1
    transfer.0 = transfer.0 fmem
    transfer.fmem = fstate
    if syd = 'Yes' then
    if fstate /= null
    then 'tbadd' ftp_Table mult
    if syd = 'No'
    then 'tbadd' ftp_Table mult
  end

  'tbtop' ftp_table
  'tbsort' ftp_table 'fields(fmem,ch,a)'
  return

Proc_Member_List:
  ztdsels = 0
  ftop = 0
  zedsmsg = null
  zedlmsg = 'Transfer eligible members:' transfer_count
  'setmsg msg(isrz001)'
  clear_flag = 0
  do forever
    fsel = null
    ftpgo = null
    if ztdsels = 0
    then do
      'tbtop' ftp_table
      'tbskip' ftp_table 'number('ftop')'
      'tbdispl' ftp_table 'panel(ftpbsmbr)'
    end
    else 'tbdispl' ftp_table
    if rc > 4 then leave
    ftop = ztdtop
    if zcmd /= null then
    Select
      When abbrev('SORT',zcmd,2) = 1 then do
        'display panel(ftpbsms)'
        if rc = 0 then do
          Select    /* primary sort */
            When s1m  /= null then field = 'fmem,ch,'s1o
            When s1s  /= null then field = 'fstate,ch,'s1o
            When s1ld /= null then field = 'ldate,ch,'s1o
            When s1lt /= null then field = 'ltime,ch,'s1o
            When s1rd /= null then field = 'rdate,ch,'s1o
            When s1rt /= null then field = 'rtime,ch,'s1o
            Otherwise field = 'fmem,ch,a'
          End
          Select    /* primary sort */
            When s2m  /= null then field = field',fmem,ch,'s2o
            When s2s  /= null then field = field',fstate,ch,'s2o
            When s2ld /= null then field = field',ldate,ch,'s2o
            When s2lt /= null then field = field',ltime,ch,'s2o
            When s2rd /= null then field = field',rdate,ch,'s2o
            When s2rt /= null then field = field',rtime,ch,'s2o
            Otherwise nop
          End
          'tbsort' ftp_table 'fields('field')'
        End
      end
      When abbrev('ONLY',zcmd,4) = 1 then do
        zcmd = null
        'tbtop' ftp_table
        do forever
          'tbskip' ftp_table
          if rc > 0 then leave
          if fstate = null then 'tbdelete' ftp_table
        end
        'tbtop' ftp_table
      end
      When abbrev('LOCATE',word(zcmd,1),1) = 1 then do
        fmem = word(zcmd,2)'*'
        newcrp = 0
        'tbscan' ftp_table 'arglist(fmem) position(newcrp) condlist(ge)'
        if rc > 0 then do
          zedsmsg = 'Not found.'
          zedlmsg = fmem 'Not found.'
          'setmsg msg(isrz001)'
        end
        else ftop = newcrp
      end
      when abbrev('CANCEL',zcmd,3) = 1 then do
        'tbend' ftp_table
        zedsmsg = 'Canceled.'
        zedlmsg = 'FTP Sync canceled.'
        'setmsg msg(isrz001)'
        'tbend' ftp_table
        return
      end
      when abbrev('CLEAR',zcmd,2) = 1 then do
        'tbtop' ftp_table
        do forever
          'tbskip' ftp_table
          if rc > 0 then leave
          fstate = null
          'tbput' ftp_table
        end
        transfer. = null
        transfer_count = 0
        'tbtop' ftp_table
        clear_flag = 1
      end
      Otherwise nop
    end
    if fsel /= null then
    select
      when fsel = 'B' then do
        if left(lpds,1) = "'" then do
          bpds = "'"strip(lpds,"B","'")"("fmem")'"
        end
        else bpds = lpds"("fmem")"
        'control display save'
        'Browse dataset('bpds')'
        'control display restore'
      end
      when fsel = 'C' then do
        if sysvar('syspref') = null
        then pref = sysvar('sysuid')
        else pref = sysvar('syspref')
        tempds = "'"pref".zftpget.r"random(9999)".data'"
        tempdd = 'FT'time('s')
        Address TSO ,
          'alloc  ds('tempds') new spa(15,15) tr like('lpds')' ,
          'dsntype(basic) dsorg(ps) f('tempdd') reuse'
        fc = 0
        if translate(psv) = 'YES' then do
          fc = fc + 1
          ftpx.fc = 'locsite fwfriendly epsv4'
        end
        if strip(other) /= null then do
          fc = fc + 1
          ftpx.fc = other
        end
        fc = fc + 1
        ftpx.fc = 'mode b'
        fc = fc + 1
        ftpx.fc = 'type e'
        fc = fc + 1
        ftpx.fc = 'cd' rpds
        fc = fc + 1
        ftpx.fc = 'get' fmem tempds '(Replace'
        fc = fc + 1
        ftpx.fc = 'quit'
        ftpx.0 = fc

        call do_ftpx

        x = listdsi(tempds)
        if sysused > 0 then do
          'control display save'
          if left(lpds,1) = "'"
          then cplds = "'"strip(lpds,'B',"'")"("fmem")'"
          else cplds = lpds"("fmem")"
          'vput (tempds rpds fmem) shared'
          'Edit dataset('cplds') macro(ftpbredt)'
          if rc > 0 then do
            'setmsg msg(isrz003)'
          end
          'control display restore'
        end
        else do
          zedsmsg = 'Error.'
          zedlmsg = 'The remote PDS member was not retrieved. This could' ,
            'be caused by the PDS/PDS-Member having an exclusive ENQ' ,
            'at the remote site.'
          'setmsg msg(isrz001)'
        end
        call outtrap 'x.'
        address tso 'free f('tempdd') delete'
        call outtrap 'off'
      end
      when fsel = 'D' then do
        fstate = 'DELETE'
        'tbput' ftp_table
        if wordpos(fmem,transfer.0) = 0 then do
          transfer.0 = transfer.0 fmem
          transfer_count = transfer_count + 1
        end
        transfer.fmem = fstate
      end
      when fsel = 'R' then do
        fstate = 'REMOVE'
        'tbput' ftp_table
        if wordpos(fmem,transfer.0) = 0 then do
          transfer.0 = transfer.0 fmem
          transfer_count = transfer_count + 1
        end
        transfer.fmem = fstate
      end
      when fsel = 'G' then do
        fstate = 'GET'
        'tbput' ftp_table
        if wordpos(fmem,transfer.0) = 0 then do
          transfer.0 = transfer.0 fmem
          transfer_count = transfer_count + 1
        end
        transfer.fmem = fstate
      end
      when fsel = 'P' then do
        fstate = 'PUT'
        'tbput' ftp_table
        transfer.fmem = fstate
        if wordpos(fmem,transfer.0) = 0 then do
          transfer.0 = transfer.0 fmem
          transfer_count = transfer_count + 1
        end
      end
      when fsel = 'I' then do
        fstate = null
        'tbput' ftp_table
        transfer.fmem = fstate
        p = wordpos(fmem,transfer.0)
        if p > 0 then do
          transfer.0 = delword(transfer.0,p,1)
          transfer_count = transfer_count - 1
        end
        if clear_flag = 1 then
        'tbdelete' ftp_table
      end
      otherwise nop
    end
  end
  'tbend' ftp_table
  if transfer_count = 0 then do
    zedsmsg = null
    zedlmsg = 'No members eligible for FTP.'
    'setmsg msg(isrz001)'
    call outtrap 'x.'
    Address TSO 'free f('ddn')'
    call outtrap 'off'
    return
  end
  drop ftpx.
  ftpc = 0
  if new = 'Yes' then do
    ftpc = ftpc + 1
    allocu = left(sysunits,1)
    allocu = pos(allocu,'BCT')
    allocu = word('Block Cylinder Track',allocu)
    rec = 'quote site recfm='sysrecfm 'blksize='sysblksize ,
      'pri='sysalloc allocu
    if sec /= null then rec = rec 'sec='sec
    if sysadirblk = 'NO_LIM'
    then pdsdir = 'P'
    else pdsdir = sysadirblk
    if pdsdir = 'P' then rec = rec 'pdstype=pdse'
    else rec = rec 'direct='pdsdir
    ftpx.ftpc = rec
    if tmclas /= null then do
      ftpc = ftpc + 1
      rec = 'quote site mg='tmclas
      if tdclas /= null then rec = rec 'datac='tdclas
      if tsclas /= null then rec = rec 'sto='tsclas
      ftpx.ftpc = rec
    end
    rec = ''
    if tunit /= null then rec = rec 'Unit='tunit
    if tvol  /= null then rec = rec 'Vol='tvol
    if rec /= null then do
      ftpc = ftpc + 1
      ftpx.ftpc = rec
    end
    ftpc = ftpc + 1
    ftpx.ftpc = 'mkdir' rpds
  end

  ftpc = ftpc + 1
  ftpx.ftpc = 'lcd' lpds
  ftpc = ftpc + 1
  ftpx.ftpc = 'cd' rpds

  do i = 1 to words(transfer.0)
    fmem = word(transfer.0,i)
    if transfer.fmem = null then iterate
    ftpc = ftpc + 1
    fstate = transfer.fmem
    if fstate = 'GET' then fmem = fmem '( Replace'
    if fstate = 'REMOVE' then do
      if left(lpds,1) = "'" then do
        parse value lpds with "'"dpds"'"
        dpds = "'"dpds"("fmem")'"
      end
      else dpds = lpds'('fmem')'
      fstate = 'TSO DELETE' dpds
      fmem = null
    end
    ftpx.ftpc = fstate fmem
    fstate = null
  end
  ftpc = ftpc + 1
  ftpx.ftpc = 'Quit'
  ftpx.0 = ftpc

  m1 = 'Processing the File Synchronization to'
  m2 = 'Host:' thost 'Port:' thport
  m3 = 'From' lpds
  m4 = 'To  ' rpds
  call do_pop4

  Address TSO ,
    "Execio * diskr" ddn "(Finis stem ftp."
  ip = ftp.0
  do i = 1 to ftpx.0
    ip = ip + 1
    ftp.ip = ftpx.i
  end
  ip = ip + 1
  ftp.ip = '/*'
  ftp.0 = ip

  Address TSO ,
    "Execio * diskw" ddn "(Finis stem ftp."

  if transfer_count = 1
  then m1 = transfer_count 'member to be processed.'
  else m1 = transfer_count 'members to be processed.'

  call Do_FTP

  return

  /*PATMATCH - copied from CBT file 656 by LBD 01-23-2021 ***************/
  /*-Start of PATMATCH function---------------------------Version-01.01-*/
  /*:PATMATCH function - Performs ISPF-type pattern matching on a pair  */
  /* of strings: 1st string is the pattern, 2nd is the data.            */
  /* Example: rc=PATMATCH('*EFG*','ABCDEFGH')                           */
  /* Returns: 0:    Pattern does not match the data.                    */
  /*          1:    Pattern does match the data.                        */
  /*          text: Error occured, text gives the details.              */
  /* Copyright (C) 1996, 1998 Washington Systems. All rights reserved.  */
  /*--------------------------------------------------------------------*/
PATMATCH: Procedure

  IF ARG() <> 2 THEN RETURN 'PATMATCH ERROR: 2 parms required, caller',
    'passed 'ARG()' parms'
  haystack = ARG(2)                  /* Data to be searched w/ pattern  */
  pattern = ARG(1)                   /* Search pattern                  */
  wild = 0                           /* No '*' seen (yet)               */
  DO WHILE pattern <> ''           /* Process pattern from L to R     */

    a = POS('*',pattern)             /* Look for '*' in pattern         */
    IF a > 0 THEN                    /* If found, extract any           */
    DO                             /*  preceeding search string       */
      PARSE VAR pattern needle '*' +0 newpattern
      IF needle = '' THEN
      DO                           /* If no preceeding search string, */
        wild = 1                     /*  mark next search as 'wild card'*/
        PARSE VAR newpattern 2 pattern /* remove '*' from pattern       */
        ITERATE                      /*    and continue testing         */
      END
    END

    p = POS('%',pattern)             /* Look for '%' in pattern         */
    IF p > 0 & (a = 0 | p < a) THEN  /* If found before any '*', extract*/
    DO                             /*  any preceeding search string   */
      PARSE VAR pattern needle '%' +0 newpattern
      IF needle = '' THEN
      DO                           /* If no preceeding search string, */
        needle = LEFT(haystack,1)    /* take next text as search string */
        PARSE VAR newpattern 2 newpattern
        wild = 0                     /* Mark next search 'not wild card'*/
      END
    END

    IF p = 0 & a = 0                 /* No special chars, use remainder */
    THEN PARSE VAR pattern needle newpattern

    pattern = newpattern             /* Update pattern for next pass    */
    pos = POS(needle,haystack)       /* Look for this pattern           */
    IF pos = 0 THEN RETURN 0         /* Not found, outta here           */
    IF pos > 1 THEN                  /* Found, but not at start-of-text */
    IF wild <> 1                   /* Wild card char in effect?       */
    THEN RETURN 0                  /* No wild card, outta here        */
    wild = 0                         /* Reset wild card character       */
    len = LENGTH(haystack)-LENGTH(needle)-pos+1
    haystack = RIGHT(haystack,len)   /* Remove data that we just scanned*/
    IF haystack = '' THEN
    DO                             /* No more data to scan...         */
      IF pattern = ''                /* Out of pattern as well?         */
      THEN RETURN 1                  /* Yes, that's a match.            */
      IF pattern = '*'               /* Did pattern end with wild card? */
      THEN RETURN 1                  /* Yes, that's a match too.        */
      RETURN 0                       /* Else, sorry, not a match.       */
    END
  END                              /* Ran out of pattern to scan      */
  IF wild = 1                        /* Did pattern end with wild card? */
  THEN RETURN 1                      /* Yes, that's a match.            */
  ELSE RETURN 0                      /* Else, sorry, not a match.       */
  /*-End of PATMATCH function-------------------------------------------*/

  /* -------------------------- *
  | Rebuild the FTPJOBCD table |
  * -------------------------- */
Update_FTPJOBCD_Table: procedure expose null
  'tbtop ftpjobcd'
  c = 0
  do forever
    c = c + 1
    t.c = targhost targport '|'rj1'|'rj2'|'rj3'|'rj4'|'targtls'|'thdesc
    'tbskip ftpjobcd'
    if rc > 0 then leave
  end
  'tbend ftpjobcd'
  'tbdelete ftpjobcd'
  "TBCreate ftpjobcd keys(targhost targport)",
    "Names(rj1  rj2  rj3 rj4 targtls thdesc)",
    "Replace  Library(ISPPROF)"
  do i = 1 to c
    parse value t.c with ,
      targhost targport '|'rj1'|'rj2'|'rj3'|'rj4'|'targtls'|'thdesc
    'tbadd ftpjobcd'
  end
  return
